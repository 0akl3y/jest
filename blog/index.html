<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Blog · Jest</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="Blog · Jest"><meta property="og:type" content="website"><meta property="og:url" content="https://facebook.github.io/jest/index.html"><meta property="og:image" content="https://facebook.github.io/jest/img/opengraph.png"><meta property="og:description" content="Painless JavaScript Unit Testing"><link rel="shortcut icon" href="/jest/img/favicon.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"><link rel="stylesheet" href="/jest/css/jest.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/jest/"><img src="/jest/img/jest_logo_nav.png">Jest</a><div class="nav-site-wrapper"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/tutorial.html#content" class="">docs</a></li><li><a href="/jest/support.html#content" class="">support</a></li><li><a href="/jest/blog/#content" class="active">blog</a></li></ul><div class="algolia-search-wrapper"><input id="algolia-doc-search" type="text" placeholder="Search docs..."></div><ul class="nav-site nav-site-external"><li><a href="https://github.com/facebook/jest" class="">GitHub</a></li></ul></div></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Recent Posts</h3><ul><li><a class="" href="/jest/blog/2016/04/12/jest-11.html">Jest 11.0</a></li><li><a class="" href="/jest/blog/2016/03/11/javascript-unit-testing-performance.html">JavaScript Unit Testing Performance</a></li></ul></div></div><div class="inner-content"><div><h1>Jest 11.0</h1><p class="meta">April 12, 2016 by <a href="http://twitter.com/cpojer" target="_blank">Christoph Pojer</a></p><hr><div><p>Today we&#x27;re announcing a switch to major revisions for Jest with Jest 11.0 being the first major release. Jest has been used by Facebook engineers and on our continuous integration systems for years and we believe Jest has been way beyond a “1.0 release” for a long time. This is similar to a change <a href="http://facebook.github.io/react/blog/2016/02/19/new-versioning-scheme.html" target="_blank">the React team has made</a>.</p><p>If you are using Jest 0.9 or Jest 0.10 the upgrade should be seamless. All changes from the last few months were rolled into Jest 11.0.</p><h3><a class="anchor" name="new-in-jest-11-0"></a>New in Jest 11.0. <a class="hash-link" href="#new-in-jest-11-0">#</a></h3><h4><a class="anchor" name="babel-integration-and-simplified-setup"></a>Babel Integration and Simplified Setup <a class="hash-link" href="#babel-integration-and-simplified-setup">#</a></h4><p><code>babel-jest</code> was adopted within the newly modularized Jest <a href="https://github.com/facebook/jest/tree/master/packages" target="_blank">repository</a> and it is now seamlessly integrated into Jest. If you are upgrading from an older version of Jest or are looking to adopt Jest, we recommend reading the <a href="http://facebook.github.io/jest/docs/getting-started.html" target="_blank">Getting Started guide</a>.</p><p>Previously Jest provided APIs such as <code>jest.dontMock</code> which unmocks a module that is subsequently being required using the <code>require</code> function. Testing code usually looked like this:</p><pre class="prism language-javascript">
jest<span class="token punctuation">.</span><span class="token function">dontMock</span><span class="token punctuation">(</span><span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> LikeButton <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span spellcheck="true" class="token comment">// LikeButton is unmocked</span></pre><p>However, together with ES2015 import statements this will no longer work. Per the specification <code>import</code>s are hoisted to the top of their code block. Code written like this:</p><pre class="prism language-javascript">
jest<span class="token punctuation">.</span><span class="token function">dontMock</span><span class="token punctuation">(</span><span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> LikeButton <span class="token keyword">from</span> <span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">;</span></pre><p>when executed, would actually be run in this order:</p><pre class="prism language-javascript">
<span class="token keyword">import</span> LikeButton <span class="token keyword">from</span> <span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">;</span> <span spellcheck="true" class="token comment">// This happens before the dontMock call.</span>
jest<span class="token punctuation">.</span><span class="token function">dontMock</span><span class="token punctuation">(</span><span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>The LikeButton module would therefore be mocked even though we explicitly call <code>dontMock</code>.</p><p>When the latest versions of Jest and babel-jest are used together, calls to the new APIs <code>jest.unmock</code>, <code>jest.mock</code>, <code>jest.disableAutomock</code> and <code>jest.enableAutomock</code> are hoisted to the top of their block, before ES2015 import statements.</p><pre class="prism language-javascript">
jest<span class="token punctuation">.</span><span class="token function">unmock</span><span class="token punctuation">(</span><span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> LikeButton <span class="token keyword">from</span> <span class="token string">&#x27;LikeButton&#x27;</span><span class="token punctuation">;</span> <span spellcheck="true" class="token comment">// LikeButton is properly unmocked!</span></pre><h4><a class="anchor" name="auto-mocking-improvements"></a>(Auto)Mocking Improvements <a class="hash-link" href="#auto-mocking-improvements">#</a></h4><p>We have made numerous improvements and bug fixes to Jest&#x27;s automocking feature, improved npm3 support and added new manual mocking APIs. Many people have expressed a desire use Jest with the automocking feature disabled. A global configuration option <a href="http://facebook.github.io/jest/docs/api.html#automock-boolean" target="_blank"><code>automock</code></a>, which can be set to <code>false</code>, was added.</p><p>We have also added two new APIs to simplify manual mocks. <code>jest.mock</code> specifies a manual mock factory for a specific test:</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// Implement a mock for a hypothetical &quot;sum&quot; module.</span>
jest<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span spellcheck="true" class="token comment">// 5</span></pre><p>And <code>jest.fn</code> was added to make it easier to create mock functions:</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// Create a mock function</span>
<span class="token keyword">const</span> mockFn <span class="token operator">=</span> jest<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mockFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span spellcheck="true" class="token comment">// 42</span>
<span class="token function">expect</span><span class="token punctuation">(</span>mockFn<span class="token punctuation">.</span>calls<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><h4><a class="anchor" name="performance"></a>Performance <a class="hash-link" href="#performance">#</a></h4><p>We recently wrote about some <a href="http://facebook.github.io/jest/blog/2016/03/11/javascript-unit-testing-performance.html" target="_blank">performance improvements</a> we&#x27;ve made in Jest. Most notably, startup time has been improved and we are now in a comfortable place with regards to performance.</p><h4><a class="anchor" name="jasmine-and-test-assertion-improvements"></a>Jasmine and Test Assertion improvements <a class="hash-link" href="#jasmine-and-test-assertion-improvements">#</a></h4><p>When Jest was open sourced it shipped with Jasmine 1. Jest was designed to work with any test assertion library and optional Jasmine 2 support was added through an <a href="https://github.com/facebook/jest/pull/330" target="_blank">external contribution</a> at the end of last year. This change delivers better performance and provides a better APIs over the previous version of Jasmine. As such, we have converted all our JavaScript tests at Facebook to Jasmine 2. With Jest 11 we are making Jasmine 2 the new default. Jasmine 1 can be enabled through the <a href="http://facebook.github.io/jest/docs/api.html#testrunner-string" target="_blank"><code>testRunner</code></a> configuration option.</p><p>We have also made many updates around Jasmine. The failure messages for custom matchers provided for Jest&#x27;s mock functions were improved and will now also work for Jasmine spies. Skipped tests, when using <code>fit</code> or <code>fdescribe,</code> are now properly reported at the end of a test run.</p><h4><a class="anchor" name="other-changes"></a>Other Changes <a class="hash-link" href="#other-changes">#</a></h4><p>The <code>jest --watch</code> command has been rewritten and improved. By default it now only runs tests related to changed files. If you want to run all tests on every change, you can run <code>jest --watch=all</code>. The verbose logger output has also been improved and we&#x27;ve added more helpful warnings and error messages. We added a <a href="http://facebook.github.io/jest/docs/api.html#testenvironment-string" target="_blank"><code>testEnvironment</code></a> configuration option to customize the test environment. For example, when building a node service, a special <code>node</code> environment instead of <code>jsdom</code> can be used. Finally, the website and all documentation have been completely rewritten.</p><p>All changes from the past few months can be found in the <a href="https://github.com/facebook/jest/blob/master/CHANGELOG.md" target="_blank">CHANGELOG</a>.</p><h3><a class="anchor" name="contributions-and-jest-s-future"></a>Contributions And Jest&#x27;s future <a class="hash-link" href="#contributions-and-jest-s-future">#</a></h3><p>Over the last six months, Jest has received significant changes from a huge number of new contributors. I&#x27;d like to thank all the open source contributors and Facebook employees for their help in making Jest better for everyone. New contributors: Alexander Juarez, Christian Lentfort, Cristian Carlesso, Dan Abramov, Dmitrii Abramov, Evan Jacobs, James Friend, James Ide, Jeff Carpenter, Joe Lencioni, Michael Diolosa, Nik Graf, Pavel Prokopenko, Pavel Volokitin, Sebastian Mayr and ShihChi Huang.</p><p>With your support we are looking forward to making Jest even better in the coming months. We are currently working on improved React (Native) testing, enhanced code coverage support and are planning to open source our internal test runner that allows multiple Jest projects to be run with a single run-command.</p></div></div><div><h1>JavaScript Unit Testing Performance</h1><p class="meta">March 11, 2016 by <a href="http://twitter.com/cpojer" target="_blank">Christoph Pojer</a></p><hr><div><p>Jest is running thousands of tests at Facebook at all times, either through continuous integration or invoked by engineers manually during development. This worked well for years even as the people working on Jest moved on to other projects within Facebook.</p><p>As engineers added more and more tests though, we noticed the performance of Jest wasn&#x27;t going to scale. Additionally, in the last year the JavaScript ecosystem has changed dramatically with the introduction of things like npm3 and Babel, which we hadn&#x27;t anticipated. We formed a new Jest team to address all of these issues and we&#x27;ll be sharing our progress and plans on this blog from now on.</p><p>Jest is a bit different from most test runners. We designed it to work well in the context of Facebook&#x27;s infrastructure:</p><ul><li><strong>Monorepo</strong>
At Facebook we have a huge monorepo that contains all of our JavaScript code. There are many reasons why this approach is advantageous for us and there is an <a href="https://www.youtube.com/watch?v=W71BTkUbdqE" target="_blank">awesome talk</a> by a Google engineer that highlights all the benefits and drawbacks of monorepos.</li><li><strong>Sandboxing</strong>
Another feature of Jest that&#x27;s important to Facebook is how it virtualizes the test environment and wraps <code>require</code> in order to sandbox code execution and isolate individual tests. We&#x27;re even working on making Jest more modular so we can take advantage of this functionality in other non-testing related use cases.</li><li><strong>providesModule</strong>
If you&#x27;ve looked at any of our open source JavaScript projects before, you may have noticed that we use a <code>@providesModule</code> header to assign globally unique IDs to modules. This does require some custom tooling, but it allows us to reference modules without relative paths which has helped us move incredibly fast, has scaled well as our engineering organization has grown, and has fostered code sharing across the entire company. Check out <a href="https://github.com/facebook/relay/blob/4eae620d86ed7fce1ee463c2fca88eb690d9cbde/src/container/RelayContainer.js#L9" target="_blank">RelayContainer</a> for an example of how this works in practice. One downside to this approach, though, is that we&#x27;re forced to read and parse our entire JavaScript codebase in order to resolve a single require statement. This would obviously be prohibitively expensive without extensive caching, especially for a short-lived process like Jest.</li></ul><p>As a result of these unique constraints, Jest may never be able to be as fast as other test runners when running on our entire suite of tests. However, engineers rarely need to run Jest on our entire test suite. Powered by static analysis in the <a href="https://github.com/facebook/node-haste" target="_blank">node-haste</a> project – we&#x27;ve been able to make the default mode for running Jest at Facebook <code>jest --onlyChanged</code>, or <code>jest -o</code>. In this mode we build a reverse dependency graph to find only the affected tests that need to be run based on the modules that have been changed.</p><h2><a class="anchor" name="optimal-scheduling-of-a-test-run"></a>Optimal Scheduling of a Test Run <a class="hash-link" href="#optimal-scheduling-of-a-test-run">#</a></h2><p>Most of the time our static analysis determines that more than one test needs to be run. The number of affected tests can be anywhere from a couple of tests to thousands. In order to speed this process up Jest parallelizes test runs across workers. This is great because most of Facebook&#x27;s development happens on remote servers with many CPU cores.</p><p>Recently we noticed Jest often seemed stuck <em>“Waiting for 3 tests”</em> for up to a minute toward the end of a run. It turned out we had a few really slow tests in our codebase that were dominating the test runtime. While we were able to speed these individual tests up significantly, we also made a change in how Jest schedules test runs. Previously we used to schedule test runs based on file system traversal, which was actually quite random. Here is an example of 11 tests in gray blocks over two workers. The size of the block is the runtime of the test:</p><p><img src="/jest/img/blog/Scheduling1.png" alt="perf-basic-scheduling"></p><p>We were randomly running a mix of fast and slow tests, and one of our slowest tests ended up running as almost all the other tests were completed, during which the second worker sat idle.</p><p>We made a change to schedule tests based on their file size which is usually a good proxy for how long a test is going to take. A test with a few thousand lines of code likely takes longer than a test with 15 lines of code. While this sped up the entire test run by about 10%, we ended up finding a better heuristic: now Jest stores the runtime of each test in a cache and on subsequent runs, it schedules the slowest tests to run first. Overall this helped improve the runtime of all tests by about 20%.</p><p>Here is an example of the same test run from before with better scheduling:</p><p><img src="/jest/img/blog/Scheduling2.png" alt="perf-improved-scheduling"></p><p>Because we are running slow tests first, Jest can sometimes seem to take a long time to start up – we only print results after the first test has completed. For the future we are planning to run previously failed tests first, because getting that info to developers as quickly as possible matters the most.</p><h2><a class="anchor" name="inline-requires-and-lazy-mocking"></a>Inline Requires and Lazy Mocking <a class="hash-link" href="#inline-requires-and-lazy-mocking">#</a></h2><p>If you have written tests using Jasmine before, they probably look like this:</p><pre class="prism language-javascript">
<span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&#x27;works&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>One special thing we do in Jest is reset the entire module registry after every single test (call to <code>it</code>) to make sure tests don&#x27;t depend on each other. Before Jest, individual tests would depend on each other and internal module state often leaked between them. As engineers removed, reordered or refactored tests, some of them started to fail, making it hard for people to understand what was going on.</p><p>Every single test in Jest receives a fresh new copy of all modules, including new versions of all mocked dependencies which take a lot of time to generate for each test. A side effect of this is that we had to call <code>require</code> manually before every test, like this:</p><pre class="prism language-javascript">
<span class="token keyword">let</span> sum<span class="token punctuation">;</span>
<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
     sum <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&#x27;works&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&#x27;works too&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span spellcheck="true" class="token comment">// This copy of sum is not the same as in the previous call to `it`.</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>We built a babel transform called <a href="https://github.com/facebook/fbjs/blob/master/scripts/babel-6/inline-requires.js" target="_blank">inline-requires</a> that removes top-level require statements and inlines them in code. For example, the line <code>const sum = require(&#x27;sum&#x27;);</code> will be removed from code, but every use of <code>sum</code> in the file will be replaced by <code>require(&#x27;sum&#x27;)</code>. With this transform we can write tests just like you&#x27;d expect in Jasmine and the code gets transformed into this:</p><pre class="prism language-javascript">
<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&#x27;works&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;sum&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>A great side-effect of inline requires is that we only require the modules that we actually use within the test itself, instead of all the modules we used in the entire file.</p><p>Which leads to another optimization: lazy mocking. The idea is to only mock modules on demand, which combined with inline requires saves us from mocking a lot of modules and all their recursive dependencies.</p><p>We were able to update all tests using a <a href="https://github.com/cpojer/js-codemod/blob/master/transforms/outline-require.js" target="_blank">codemod</a> in no time – it was a <em>simple</em> 50,000 line code change. Inline requires and lazy mocking improved the test runtime by 50%.</p><p>The inline-require babel plugin is not only useful for Jest but for normal JavaScript as well. It was shipped by <a href="https://twitter.com/voideanvalue" target="_blank">Bhuwan</a> to all users of <a href="http://facebook.com/" target="_blank">facebook.com</a> just a week ago and significantly improved startup time.</p><p>For now, if you&#x27;d like to use this transform in Jest you&#x27;ll have to add it manually to your Babel configuration. We are working on ways to make this easier to opt-in.</p><h2><a class="anchor" name="repo-sync-and-caching"></a>Repo-Sync and Caching <a class="hash-link" href="#repo-sync-and-caching">#</a></h2><p>The open source version of Jest used to be a fork of our internal version, and we&#x27;d sync Jest out only once every couple of months. This was a painful manual process that required fixing up many tests every time. We recently upgraded Jest and brought parity to all platforms (iOS, Android and web) and then enabled our sync process. Now, every change to Jest in open source is run against all of our internal tests, and there&#x27;s only a single version of Jest that&#x27;s consistent everywhere.</p><p>The first feature we got to take advantage of after unforking was the preprocessor cache. If you are using Babel together with Jest, Jest has to pre-process every JavaScript file before it can execute it. We built a caching layer so that each file, when unchanged, only has to be transformed a single time. After we unforked Jest, we were able to easily fix up the open source implementation and shipped it at Facebook. This resulted in another 50% performance win. Because the cache only works on the second-run, the cold start time of Jest was unaffected.</p><p>We also realized we were doing a lot of path operations when resolving relative requires. Because the module registry is reset for every test, there were thousands of calls that could be memoized. One big optimization was to add a lot more caching, not just around a single test, but also across test files. Previously, we would generate module metadata for the automocking feature once for every test file. The object a module exports never changes however, so we now share this code across test files. Unfortunately, because JavaScript and Node.js don&#x27;t have shared memory, we have to do all of this work at least once per worker process.</p><h2><a class="anchor" name="question-everything"></a>Question Everything <a class="hash-link" href="#question-everything">#</a></h2><p>When trying to improve performance, it&#x27;s important to also dive into the systems that sit above and below your system. In the case of Jest, things like Node.js and the test files themselves, for example. One of the first things we did was to update Node.js at Facebook from the years-old 0.10 to iojs and subsequently to Node 4. The new version of V8 helped improve performance and was quite easy to upgrade to.</p><p> We noticed that the <code>path</code> module in Node.js is slow when making thousands of path operations which was <a href="https://github.com/nodejs/node/pull/5123" target="_blank">fixed in Node 5.7</a>. Until we drop support for Node 4 internally at Facebook, we&#x27;ll ship our own version of the <a href="https://github.com/facebook/node-haste/blob/master/src/fastpath.js" target="_blank">fastpath</a> module.</p><p>We next started questioning the outdated <a href="https://github.com/facebook/node-haste" target="_blank">node-haste</a>. As mentioned before, the entire project has to be parsed for <code>@providesModule</code> headers to build a dependency graph. When this system was originally built, <code>node_modules</code> didn&#x27;t exist and our file system crawler wasn&#x27;t excluding them properly.</p><p>In previous versions, Jest would actually read every file in <code>node_modules</code> – which contributed to the slow startup time of Jest. When we picked up Jest again we replaced the entire project with a new implementation, based on react-native&#x27;s packager. The startup time of Jest is now less than a second even on large projects. The react-native team, specifically <a href="https://twitter.com/void_0" target="_blank">David</a>, <a href="https://twitter.com/amasad" target="_blank">Amjad</a> and <a href="https://twitter.com/martinbigio" target="_blank">Martin</a> did an outstanding job on this project.</p><h2><a class="anchor" name="adding-everything-up"></a>Adding everything up <a class="hash-link" href="#adding-everything-up">#</a></h2><p>A lot of the above changes improved the test runtime by 10% or sometimes even 50%. We started at a runtime of about 10 minutes for all tests, and without these improvements we&#x27;d probably be at around 20 minutes by now. After these improvements, though, it now consistently takes around 1 minute and 35 seconds to run all our tests!</p><p>More importantly, adding new tests causes total runtime to grow very slowly. Engineers can write and run more tests without feeling the costs.</p><p>With Jest&#x27;s recent 0.9 release and performance improvements from the <a href="https://github.com/facebook/jest/pull/599" target="_blank">node-haste2 integration</a>, the runtime of the <a href="https://github.com/facebook/relay" target="_blank">Relay</a> framework&#x27;s test suite went down from 60 seconds to about 25 and the <a href="https://github.com/facebook/react-native" target="_blank">react-native</a> test suite now finishes in less than ten seconds on a 13” MacBook Pro.</p><p>We&#x27;re very happy with the wins we&#x27;ve seen so far, and we&#x27;re going to keep working on Jest and making it better. If you are curious about contributing to Jest, feel free get in touch on GitHub, <a href="http://facebook.github.io/jest/support.html" target="_blank">Discord</a> or Facebook :)</p></div></div><div class="docs-prevnext"></div></div></section><footer class="wrap"><div class="right">© 2016 Facebook Inc.</div></footer></div><div id="fb-root"></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-387204-10', 'facebook.github.io');
            ga('send', 'pageview');

            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)
            ){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");

            docsearch({
              apiKey: '833906d7486e4059359fa58823c4ef56',
              indexName: 'jest',
              inputSelector: '#algolia-doc-search'
            });
          </script></body></html>