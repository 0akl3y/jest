<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Configuring Jest · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Configuring Jest · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Configurarea Jest poate fi definită fie în fişierul `package.json` al proiectului vostru, fie într-un fișier `jest.config.js`, fie prin opţiunea `--config&lt;path/to/js|json&gt;`. Dacă doriţi să folosiți fișierul `package.json` pentru a defini configurarea, proprietatea &quot;jest&quot; ar trebui folosită, astfel încât Jest va şti cum să găsească setările:"/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ro/getting-started.html" target="_self">Documentație</a></li><li><a href="/jest/docs/ro/api.html" target="_self">API</a></li><li><a href="/jest/ro/help.html" target="_self">Ajutor</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/jest-object.html">The Jest Object</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ro/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/snapshot-testing.html">Testarea de imagine</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Configuring Jest</h1></header><article><div><span><p>Configurarea Jest poate fi definită fie în fişierul <code>package.json</code> al proiectului vostru, fie într-un fișier <code>jest.config.js</code>, fie prin opţiunea <code>--config&lt;path/to/js|json&gt;</code>. Dacă doriţi să folosiți fișierul <code>package.json</code> pentru a defini configurarea, proprietatea &quot;jest&quot; ar trebui folosită, astfel încât Jest va şti cum să găsească setările:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-project"</span>,
  <span class="hljs-attr">"jest"</span>: {
    <span class="hljs-attr">"verbose"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<p>Sau prin intermediul JavaScript:</p>
<pre><code class="language-js"><span class="hljs-comment">// jest.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">verbose</span>: <span class="hljs-literal">true</span>,
};
</code></pre>
<p>Reţineţi că toată configuraţia care rezultă trebuie să fie serializabilă JSON.</p>
<p>Când folosiți opţiunea --config, fişierul JSON nu trebuie să conțină o cheie &quot;jest&quot;:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"bail"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"verbose"</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<h2><a class="anchor" name="op-iuni"></a>Opțiuni <a class="hash-link" href="#op-iuni">#</a></h2>
<p>Aceste opţiuni vă vor permite să controlați comportamentul Jest din fişierul <code>package.json</code>. Filosofia Jest este să funcționeze bine din start, însă uneori, e nevoie de mai multă putere de configurare.</p>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referin-e"></a>Referințe <a class="hash-link" href="#referin-e">#</a></h2>
<h3><a class="anchor" name="automock-boolean"></a><code>automock</code> [boolean] <a class="hash-link" href="#automock-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Această opțiune este dezactivată implicit. În cazul în care introduceți Jest într-o organizație mai mare cu mult cod existent însă doar câteva teste, această opţiune poate fi utilă pentru introducerea treptată a testelor unitare. Modulele pot fi dublate explicit în mod automat folosind <code>jest.mock(moduleName)</code>.</p>
<p><em>Notă: Modulele de bază, cum ar fi <code>fs</code>, nu sunt dublate în mod implicit. Acestea pot fi dublate în mod explicit, cu <code>jest.mock('fs')</code>.</em></p>
<p><em>Nota: Dublarea automată are un cost de performanţă vizibil în special în proiectele mari. A se vedea <a href="troubleshooting.html#tests-are-slow-when-leveraging-automocking">aici</a> pentru detalii şi soluţii.</em></p>
<h3><a class="anchor" name="browser-boolean"></a><code>browser</code> [boolean] <a class="hash-link" href="#browser-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Respectă <a href="https://github.com/substack/browserify-handbook#browser-field"> câmpul <code>&quot;browser&quot;</code></a> al Browserify în <code>package.json</code> când se rezolvă modulele. Unele module exportă versiuni diferite dacă operează în Node sau browser.</p>
<h3><a class="anchor" name="bail-boolean"></a><code>bail</code> [boolean] <a class="hash-link" href="#bail-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>În mod implicit, Jest ruleaza toate testele şi produce toate erorile în consolă la final. Această opțiune poate fi folosită pentru oprirea execuției Jest după primul eşec.</p>
<h3><a class="anchor" name="cachedirectory-string"></a><code>cacheDirectory</code> [string] <a class="hash-link" href="#cachedirectory-string">#</a></h3>
<p>Implicit: <code>&quot;/tmp/&lt;path&gt;&quot;</code></p>
<p>Directorul unde Jest va stoca informaţiile sale de dependenţe.</p>
<p>Jest încearcă să scaneze arborele de dependenţe o dată şi îl memorează pentru a ușura lucrul cu sistemul de fişiere care trebuie să se întâmple în timp ce rulează teste. Această opţiune de configurare vă permite să particularizaţi unde Jest stochează datele pe disc.</p>
<h3><a class="anchor" name="collectcoverage-boolean"></a><code>collectCoverage</code> [boolean] <a class="hash-link" href="#collectcoverage-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Indică dacă informaţiile de acoperire a codului trebuie să fie colectate în timpul execuției. Deoarece aceasta adaugă în toate fişierele executate declaraţii de colectare a acoperirii, poate încetini semnificativ testele.</p>
<h3><a class="anchor" name="collectcoveragefrom-array"></a><code>collectCoverageFrom</code> [array] <a class="hash-link" href="#collectcoveragefrom-array">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>O serie de <a href="https://github.com/jonschlinkert/micromatch">modele de tip glob</a> care indică setul de fişiere pentru care trebuie colectate informaţii de acoperire. Dacă un fişier se potriveşte cu modelul specificat, informaţiile de acoperire vor fi colectate pentru acesta chiar dacă nu există teste pentru acest fişier sau nu este apelat în suita de teste.</p>
<p>Exemplu:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"collectCoverageFrom"</span> : [<span class="hljs-string">"**/*.{js,jsx}"</span>, <span class="hljs-string">"!**/node_modules/**"</span>, <span class="hljs-string">"!**/vendor/**"</span>]
}
</code></pre>
<p>Acest exemplu va colecta informaţii de acoperire pentru toate fişierele din rădăcina proiectului <code>rootDir</code>, cu excepția celor din <code>**/node_modules/**</code> și <code>**/vendor/**</code>.</p>
<p><em>Notă: Această opţiune necesită ca opțiunea <code>collectCoverage</code> să fie setată &quot;true&quot; sau Jest să fie invocat cu <code>--coverage</code>.</em></p>
<h3><a class="anchor" name="coveragedirectory-string"></a><code>coverageDirectory</code> [string] <a class="hash-link" href="#coveragedirectory-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>Directorul unde Jest ar trebui să salveze fişierele sale de acoperire.</p>
<h3><a class="anchor" name="coveragepathignorepatterns-array-string"></a><code>coveragePathIgnorePatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#coveragepathignorepatterns-array-string">#</a></h3>
<p>Implicit: <code>[&quot;/node_modules/&quot;]</code></p>
<p>O serie de expresii regulate care sunt comparate cu toate căile fişierelor înainte de execuția testelor. Pentru toate fişierele care se potrivesc cu oricare dintre reguli, informaţiile de acoperire vor fi ignorate.</p>
<p>Aceste reguli sunt comparate față de calea completă. Utilizaţi cuvântul cheie <code>&lt;rootDir&gt;</code> pentru a include calea către directorul rădăcină din proiectul vostru pentru a preveni ignorarea accidentală a fișierelor în medii diferite, care pot avea diferite directoare rădăcină. Exemplu: <code>[&quot;&lt;rootDir&gt;/build/&quot;, &quot;&lt;rootDir&gt;/node_modules/&quot;]</code>.</p>
<h3><a class="anchor" name="coveragereporters-array-string"></a><code>coverageReporters</code> [array&lt;string&gt;] <a class="hash-link" href="#coveragereporters-array-string">#</a></h3>
<p>Implicit: <code>[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;]</code></p>
<p>O listă de tipuri de repoarte pe care Jest le utilizează pentru scrierea rapoartelor de acoperire. Poate fi folosit oricare din cele prezente în <a href="https://github.com/gotwarlost/istanbul/tree/master/lib/report">istanbul</a>.</p>
<p><em>Notă: Setarea acestei opțiuni suprascrie valorile implicite. Adăugă <code>&quot;text&quot;</code> sau <code>&quot;text-summary&quot;</code> pentru a vedea un rezumat de acoperire în consolă.</em></p>
<h3><a class="anchor" name="coveragethreshold-object"></a><code>coverageThreshold</code> [object] <a class="hash-link" href="#coveragethreshold-object">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>Acesta va fi utilizat pentru a configura pragul minim de acoperire. În cazul în care pragurile nu sunt atinse, jest va returna un eșec. Atunci când valoarea specificată este un număr pozitiv, se consideră a fi procentului minim necesar. Atunci când un prag este specificat ca un număr negativ, el reprezintă numărul maxim permis de entități neacoperite. Limitele pot fi specificate <code>la nivel global</code>, căi <code>glob</code> sau doar căi simple. If globs or paths are specified alongside <code>global</code>, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Pragul pentru glob-uri se aplică la toate fişierele incluse în glob. Dacă nu se regăsește fișierul specificat în cale, se returnează eroare.</p>
<p>De exemplu, statements: 90 implică o acoperire minimă de declaraţii de 90%. statements: -10 implică faptul că se acceptă cel mult 10 declarații neacoperite. Pragul branch 50 <code>global</code> va fi aplicat la toate fişierele, mai puțin cele din <code>./src/components/**/*.js</code> şi <code>./src/api/very-important-module.js</code>.</p>
<pre><code class="language-json">{
  ...
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 50,
        "functions": 50,
        "lines": 50,
        "statements": 50
      },
      "./src/components/**/*.js": {
        "branches": 40,
        "statements": 40
      },
      "./src/api/very-important-module.js": {
        "branches": 100,
        "functions": 100,
        "lines": 100,
        "statements": 100
      }
    }
  }
}
</code></pre>
<h3><a class="anchor" name="globals-object"></a><code>globals</code> [object] <a class="hash-link" href="#globals-object">#</a></h3>
<p>Implicit: <code>{}</code></p>
<p>Un set de variabile globale care trebuie să fie disponibile în toate mediile de testare.</p>
<p>De exemplu, următorul cod ar crea o variabilă globală <code>__DEV__</code> cu valoarea <code>true</code> în toate mediile de testare:</p>
<pre><code class="language-json">{
  ...
  "jest": {
    "globals": {
      "__DEV__": true
    }
  }
}
</code></pre>
<p>Reţineţi că, dacă specificaţi o valoare de referinţă la nivel global (cum ar fi un obiect sau un array), şi în mijlocul execuției unui test se modifică această valoare, modificarea <em>nu</em> va persista în rularea testelor pentru alte fişiere de test.</p>
<h3><a class="anchor" name="mapcoverage-boolean"></a><code>mapCoverage</code> [boolean] <a class="hash-link" href="#mapcoverage-boolean">#</a></h3>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<p>Implicit: <code>false</code></p>
<p>Dacă aveţi <a href="#transform-object-string-string">transformatoare</a> configurate să genereze &quot;source maps&quot;, Jest le va utiliza pentru a încerca să mapeze acoperirea cu codul sursă original atunci când generează <a href="#coveragereporters-array-string">rapoarte</a> sau verifică <a href="#coveragethreshold-object">praguri</a>. Acest lucru se face cât de bine se poate, deoarece unele limbaje care se compilează a JavaScript poate oferi &quot;source maps&quot; mai precise decât altele. Acest lucru poate consuma, de asemenea, multe resurse. Dacă Jest pierde o lungă perioadă de timp pentru a calcula acoperirea de cod la finalul unei rulări de teste, încercaţi să setaţi această opţiune <code>false</code>.</p>
<p>Sunt suportate atât &quot;source maps&quot; inline cât şi cele generate direct de către un transformator. &quot;Source maps&quot; definite prin URL nu sunt acceptate deoarece Jest nu le-ar putea localiza. Pentru a returna &quot;source maps&quot; dintr-un transformator, funcţia <code>process</code> poate returna un obiect de felul următor. Proprietatea <code>map</code> poate fi obiectul &quot;source map&quot; sau reprezentarea acestuia sub formă JSON.</p>
<pre><code class="language-js"><span class="hljs-keyword">return</span> {
  <span class="hljs-attr">code</span>: <span class="hljs-string">'the code'</span>,
  <span class="hljs-attr">map</span>: <span class="hljs-string">'the source map'</span>,
};
</code></pre>
<h3><a class="anchor" name="modulefileextensions-array-string"></a><code>moduleFileExtensions</code> [array&lt;string&gt;] <a class="hash-link" href="#modulefileextensions-array-string">#</a></h3>
<p>Implicit: <code>[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;node&quot;]</code></p>
<p>O serie de extensii de fişiere care sunt utilizate în module. Dacă includeți module fără a specifica extensia, acestea sunt extensiile pe care Jest le va căuta.</p>
<p>Dacă folosiţi TypeScript acesta ar trebui să fie <code>[&quot;js&quot;, &quot;jsx&quot;, &quot;json&quot;, &quot;ts&quot;, &quot;tsx&quot;]</code>, verificaţi <a href="https://github.com/kulshekhar/ts-jest">documentaţia ts-jest</a>.</p>
<h3><a class="anchor" name="moduledirectories-array-string"></a><code>moduleDirectories</code> [array&lt;string&gt;] <a class="hash-link" href="#moduledirectories-array-string">#</a></h3>
<p>Implicit: <code>[&quot;node_modules&quot;]</code></p>
<p>O serie de nume de directoare care vor fi cautate recursiv pentru locaţia modulelor incluse. Setarea acestei opțiuni va <em>suprascrie</em> valoarea implicită, așadar dacă doriţi să căutaţi în continuare în <code>node_modules</code> atunci includeți-l împreună cu orice alte opţiuni: <code>[&quot;node_modules&quot;, &quot;bower_components&quot;]</code></p>
<h3><a class="anchor" name="modulenamemapper-object-string-string"></a><code>moduleNameMapper</code> [object&lt;string, string&gt;] <a class="hash-link" href="#modulenamemapper-object-string-string">#</a></h3>
<p>Implicit: <code>null</code></p>
<p>O mapare între expresii regulate și nume de module, care permit dublarea unor resurse, cum ar fi imagini sau stiluri, cu un singur alt modul.</p>
<p>Modulele care sunt mapate la un alias sunt de-dublate în mod implicit, indiferent dacă dublarea automată este activată sau nu.</p>
<p>Utilizaţi <code>&lt;rootDir&gt;</code> pentru a vă referi la valoarea <a href="#rootdir-string"><code>rootDir</code></a>, dacă doriţi să utilizaţi căi de fişier.</p>
<p>În plus, puteţi înlocui grupuri capturate cu regex folosind referințe numerotate.</p>
<p>Exemplu:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"moduleNameMapper"</span>: {
    <span class="hljs-attr">"^image![a-zA-Z0-9$_-]+$"</span>: <span class="hljs-string">"GlobalImageStub"</span>,
    <span class="hljs-attr">"^[./a-zA-Z0-9$_-]+\.png$"</span>: <span class="hljs-string">"&lt;rootDir&gt;/RelativeImageStub.js"</span>,
    <span class="hljs-attr">"module_name_(.*)"</span>: <span class="hljs-string">"&lt;rootDir&gt;/substituted_module_$1.js"</span>
  }
}
</code></pre>
<p><em>Notă: Dacă folosiți nume fără limite <code>^$</code> pot apărea erori greu de identificat. Ex. <code>relay</code> va înlocui toate modulele care contin <code>relay</code> în nume: <code>relay</code>, <code>react-relay</code> şi <code>graphql-relay</code> vor fi redirecționate către dublură.</em></p>
<h3><a class="anchor" name="modulepathignorepatterns-array-string"></a><code>modulePathIgnorePatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#modulepathignorepatterns-array-string">#</a></h3>
<p>Implicit: <code>[]</code></p>
<p>Un array de expresii regulate care sunt comparate cu toate căile de module, înainte de acestea să fie considerate 'vizibile' pentru încărcătorul de module. În cazul în care calea unui modul se potriveşte cu oricare dintre modele, acesta nu va fi <code>require()</code>-uit în mediul de testare.</p>
<p>Aceste reguli sunt comparate față de calea completă. Utilizaţi cuvântul cheie <code>&lt;rootDir&gt;</code> pentru a include calea către directorul rădăcină din proiectul vostru pentru a preveni ignorarea accidentală a fișierelor în medii diferite, care pot avea diferite directoare rădăcină. Exemplu: <code>[&quot;&lt;rootDir&gt;/build/&quot;]</code>.</p>
<h3><a class="anchor" name="modulepaths-array-string"></a><code>modulePaths</code> [array&lt;string&gt;] <a class="hash-link" href="#modulepaths-array-string">#</a></h3>
<p>Implicit: <code>[]</code></p>
<p>Un API alternativ pentru stabilirea variabilei <code>NODE_PATH</code>, <code>modulePaths</code> este un array de căi absolute pentru locații suplimentare de căutare atunci când se rezolvă modulele. Utilizaţi atributul <code>&lt;rootDir&gt;</code> pentru a include rădăcina proiectului vostru. Exemplu: <code>[&quot;&lt;rootDir&gt;/app/&quot;]</code>.</p>
<h3><a class="anchor" name="notify-boolean"></a><code>notify</code> [boolean] <a class="hash-link" href="#notify-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Activează afișsarea de notificări pentru rezultatele testelor.</p>
<h3><a class="anchor" name="preset-string"></a><code>preset</code> [string] <a class="hash-link" href="#preset-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>Presetare utilizată ca bază pentru configurarea Jest. O presetare ar trebui să indice către un modul npm care exportă un modul <code>jest-preset.json</code> pe nivelul de sus.</p>
<h3><a class="anchor" name="projects-array-string"></a><code>projects</code> [array&lt;string&gt;] <a class="hash-link" href="#projects-array-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>Atunci când configuraţia <code>projects</code> este completată cu o serie de căi sau tipare glob, Jest va rula testele în toate proiectele specificate, în acelaşi timp. Acest lucru este util pentru proiecte monolit sau atunci când se lucrează pe mai multe proiecte în acelaşi timp.</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"projects"</span>: [
    <span class="hljs-string">"&lt;rootDir&gt;"</span>,
    <span class="hljs-string">"&lt;rootDir&gt;/examples/*"</span>
  ]
}
</code></pre>
<p>Acest exemplu de configurare va rula Jest în directorul rădăcină, precum şi în fiecare subdirector din directorul &quot;examples&quot;. Puteţi avea un număr nelimitat de proiecte care rulează în aceeaşi instanță Jest.</p>
<h3><a class="anchor" name="clearmocks-boolean"></a><code>clearMocks</code> [boolean] <a class="hash-link" href="#clearmocks-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Curăță automat apelurile către dubluri şi instanțele după fiecare test. Echivalent cu apelarea <code>jest.clearAllMocks()</code> după fiecare test. Aceasta nu elimină nicio implementare de dubluri, ce a fost furnizată.</p>
<h3><a class="anchor" name="reporters-array-modulename-modulename-options"></a><code>reporters</code> [array&lt;modulename | [modulename, options]&gt;] <a class="hash-link" href="#reporters-array-modulename-modulename-options">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<p>Utilizaţi această opţiune de configurare pentru a adăuga tipuri personalizate de raportări Jest. Un reporter personalizat este o clasă care implementează metodele <code>onRunStart</code>, <code>onTestStart</code>, <code>onTestResult</code>, <code>onRunComplete</code>, ce vor fi apelate atunci când oricare din aceste evenimente survine.</p>
<p>Dacă sunt specificați reporteri personalizați, atunci cei impliciți din Jest vor fi suprascriși. Pentru a păstra reporterii impliciți, <code>default</code> poate fi adăugat.</p>
<p>Acest lucru va suprascrie reporterii impliciți:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"reporters"</span>: [
    <span class="hljs-string">"&lt;rootDir&gt;/my-custom-reporter.js"</span>
  ]
}
</code></pre>
<p>Acest lucru va utiliza reporterul personalizat în plus faţă de cei impliciți pe care Jest îi oferă:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"reporters"</span>: [
    <span class="hljs-string">"default"</span>,
    <span class="hljs-string">"&lt;rootDir&gt;/my-custom-reporter.js"</span>
  ]
}
</code></pre>
<p>În plus, reporterii personalizați pot fi configurați prin pasarea unui obiect <code>options</code> ca al doilea argument:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"reporters"</span>: [
    <span class="hljs-string">"default"</span>,
    [<span class="hljs-string">"&lt;rootDir&gt;/my-custom-reporter.js"</span>, {<span class="hljs-attr">"banana"</span>: <span class="hljs-string">"yes"</span>, <span class="hljs-attr">"pineapple"</span>: <span class="hljs-string">"no"</span>}]
  ]
}
</code></pre>
<p>Modulele pentru reporteri personalizați trebuie să definească o clasă care primește <code>GlobalConfig</code> şi un obiect &quot;options&quot; ca argumente în constructor:</p>
<p>Exemplu de reporter:</p>
<pre><code class="language-js"><span class="hljs-comment">// my-custom-reporter.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomReporter</span> </span>{
  <span class="hljs-keyword">constructor</span>(globalConfig, options) {
    <span class="hljs-keyword">this</span>._globalConfig = globalConfig;
    <span class="hljs-keyword">this</span>._options = options;
  }

  onRunComplete(contexts, results) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Custom reporter output:'</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GlobalConfig: '</span>, <span class="hljs-keyword">this</span>._globalConfig);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Options: '</span>, <span class="hljs-keyword">this</span>._options);
  }
}

<span class="hljs-built_in">module</span>.exports = MyCustomReporter;
</code></pre>
<p>Reporterii personalizați pot forţa Jest să-ți termine execuția cu cod non-0 prin returnarea unui obiect Error în metoda <code>getLastError()</code></p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomReporter</span> </span>{
  <span class="hljs-comment">// ...</span>
  getLastError() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._shouldFail) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'my-custom-reporter.js reported an error'</span>);
    }
  }
}
</code></pre>
<p>Pentru lista completă a metodelor şi tipurilor de argumente vedeți tipurile pentru <code>Reporter</code> în <a href="https://github.com/facebook/jest/blob/master/types/TestRunner.js"> types/TestRunner.js</a></p>
<h3><a class="anchor" name="resetmocks-boolean"></a><code>resetMocks</code> [boolean] <a class="hash-link" href="#resetmocks-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Resetează automat starea dublurilor după fiecare test. Echivalent cu apelarea <code>jest.clearAllMocks()</code> după fiecare test. Acest lucru va conduce la eliminearea implementării false pentru toate dublurile, dar nu restaurează implementarea lor iniţială.</p>
<h3><a class="anchor" name="resetmodules-boolean"></a><code>resetModules</code> [boolean] <a class="hash-link" href="#resetmodules-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Dacă este activată, registrul de module pentru fiecare fişier de test va fi resetat înainte de rularea fiecărui test individual. Acest lucru este util pentru a izola modulele pentru fiecare test, astfel încât starea locală a modului nu intră în conflict între teste. Acest lucru se poate face programatic folosind <a href="#jest-resetmodules"> <code>jest.resetModules()</code></a>.</p>
<h3><a class="anchor" name="resolver-string"></a><code>resolver</code> [string] <a class="hash-link" href="#resolver-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<p>Această opţiune permite utilizarea unei metode personalizate pentru rezolvarea modulelor. Acest instrument de rezolvare trebuie să fie un modul Node care exportă o funcţie ce aşteaptă ca prim argument un şir de caractere pentru calea de rezolvat şi un obiect cu următoarea structură ca al doilea argument:</p>
<pre><code>{
  &quot;basedir&quot;: string,
  &quot;browser&quot;: bool,
  &quot;extensions&quot;: [string],
  &quot;moduleDirectory&quot;: [string],
  &quot;paths&quot;: [string],
  &quot;rootDir&quot;: [string]
}
</code></pre>
<p>Funcţia ar trebui să returneze fie calea către modulul care ar trebui să fie rezolvat sau să arunce o eroare în cazul în care modulul nu poate fi găsit.</p>
<h3><a class="anchor" name="rootdir-string"></a><code>rootDir</code> [string] <a class="hash-link" href="#rootdir-string">#</a></h3>
<p>Default: The root of the directory containing your jest's <a href="#">config file</a> <em>or</em> the <code>package.json</code> <em>or</em> the <a href="http://en.wikipedia.org/wiki/Pwd"><code>pwd</code></a> if no <code>package.json</code> is found</p>
<p>Directorul rădăcină în care Jest ar trebui să caute teste şi module. Dacă puneți configurarea Jest în interiorul fișierului <code>package.json</code> şi doriţi ca directorul rădăcină a fie rădăcina proiectului vostru, valoarea pentru această configurare va fi implicit directorul cu <code>package.json</code>.</p>
<p>Deseori, veţi dori să setați această valoare la <code>&quot;src&quot;</code> sau <code>&quot;lib&quot;</code>, corespunzător locației unde stocați codul sursă.</p>
<p><em>Reţineţi că folosind <code>'&lt;rootDir&gt;'</code> în orice altă configurare de căi, va referi înapoi la această valoare. De exemplu, dacă doriţi configurarea <a href="#setupfiles-array"> <code>setupFiles</code></a> să indice către fișierul <code>env-setup.js</code> din rădăcina proiectul vostru, puteți seta valoarea sa la <code>[&quot;&lt;rootDir&gt;/env-setup.js&quot;]</code>.</em></p>
<h3><a class="anchor" name="roots-array-string"></a><code>roots</code> [array&lt;string&gt;] <a class="hash-link" href="#roots-array-string">#</a></h3>
<p>Implicit: <code>[&quot;&lt;rootDir&gt;&quot;]</code></p>
<p>O listă de căi de directoare pe care Jest ar trebui să le utilizeze pentru a căuta fișiere.</p>
<p>Există cazuri în care doriţi ca Jest să căute într-un singur sub-director (în cazul în care aveţi un director <code>src/</code>), dar doriți să preveniți accesarea celorlalte directoare.</p>
<p><em>Notă: În timp ce <code>rootDir</code> este folosit mai ales ca un simbol pentru reutilizare în alte opţiuni de configurare, <code>roots</code> este folosit intern de Jest pentru a localiza <strong>fişierele test și sursă</strong>. Acest lucru se aplică și atunci când se caută mock-uri manuale pentru module din <code>node_modules</code> (<code>__mocks__</code> va trebui să fie într-una din <code>rădăcini</code>).</em></p>
<p><em>Notă: În mod implicit, <code>roots</code> are o singură intrare <code>&lt;rootDir&gt;</code>, dar există cazuri în care v-ați dori să aveţi mai multe rădăcini într-un proiect, de exemplu <code>roots: [&quot;&lt;rootDir&gt; /src/&quot;, &quot;&lt; rootDir&gt;/tests/&quot;]</code>.</em></p>
<h3><a class="anchor" name="setupfiles-array"></a><code>setupFiles</code> [array] <a class="hash-link" href="#setupfiles-array">#</a></h3>
<p>Implicit: <code>[]</code></p>
<p>Căi către module care se execută pentru a configura sau pregăti mediul de testare înainte de fiecare test. Deoarece fiecare test se execută în propriul său mediu, aceste module vor fi executate în mediul de testare imediat înainte de execuția codului de testare în sine.</p>
<p>Este demn de remarcat faptul că acest cod se va executa <em>înainte de</em> <a href="#setuptestframeworkscriptfile-string"> <code>setupTestFrameworkScriptFile</code></a>.</p>
<h3><a class="anchor" name="setuptestframeworkscriptfile-string"></a><code>setupTestFrameworkScriptFile</code> [string] <a class="hash-link" href="#setuptestframeworkscriptfile-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>Căi către module care se execută pentru a configura sau pregăti mediul de testare înainte de fiecare test. Deoarece <a href="#setupfiles-array"><code>setupFiles</code></a> se execută înainte de instalarea framework-ului în mediul de testare, această opțiune vă oferă posibilitatea de a rula bucăți de cod imediat după ce framework-ul a fost instalat în mediul de testare.</p>
<p>De exemplu, Jest este livrat cu mai multe plug-in-uri <code>jasmine</code>, care modifică API-ul jasmine. Dacă vreți să adăugaţi si alte plugin-uri jasmine (sau dacă aveți nevoie de comparatori personalizați, la nivel de proiect, de exemplu), ați putea face acest lucru în această configurare.</p>
<h3><a class="anchor" name="snapshotserializers-array-string"></a><code>snapshotSerializers</code> [array&lt;string&gt;] <a class="hash-link" href="#snapshotserializers-array-string">#</a></h3>
<p>Implicit: <code>[]</code></p>
<p>O listă de căi către module de serializare, pe care Jest le va utiliza pentru testarea de imagine.</p>
<p>Jest are serializatori impliciți pentru tipurile JavaScript, elemente HTML (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) şi elemente React. See <a href="/jest/docs/ro/tutorial-react-native.html#snapshot-test">snapshot test tutorial</a> for more information.</p>
<p>Exemplu de modul serializator:</p>
<pre><code class="language-js"><span class="hljs-comment">// my-serializer-module</span>
<span class="hljs-built_in">module</span>.exports = {
  print(val, serialize, indent) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Pretty foo: '</span> + serialize(val.foo);
  },

  test(val) {
    <span class="hljs-keyword">return</span> val &amp;&amp; val.hasOwnProperty(<span class="hljs-string">'foo'</span>);
  },

};
</code></pre>
<p><code>serialize</code> este o funcţie care serializează o valoare folosind plugin-uri existente.</p>
<p>Pentru a utiliza <code>my-serializer-module</code> ca serializator, configuraţia ar fi după cum urmează:</p>
<pre><code class="language-json">{
  ...
  "jest": {
    "snapshotSerializers": ["my-serializer-module"]
  }
}
</code></pre>
<p>În cele din urmă testul ar arăta după cum urmează:</p>
<pre><code class="language-js">test(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> bar = {
    <span class="hljs-attr">foo</span>: {
      <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
    },
  };

  expect(bar).toMatchSnapshot();
});
</code></pre>
<p>Imaginea obținută:</p>
<pre><code>Pretty foo: Object {
  &quot;x&quot;: 1,
  &quot;y&quot;: 2,
}
</code></pre>
<p>To make a dependency explicit instead of implicit, you can call <a href="/jest/docs/ro/expect.html#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer</code></a> to add a module for an individual test file instead of adding its path to <code>snapshotSerializers</code> in Jest configuration.</p>
<h3><a class="anchor" name="testenvironment-string"></a><code>testEnvironment</code> [string] <a class="hash-link" href="#testenvironment-string">#</a></h3>
<p>Implicit: <code>&quot;jsdom&quot;</code></p>
<p>Mediul de testare care va fi utilizat pentru testare. Mediul implicit în Jest este un mediu similar unui browser, și anume <a href="https://github.com/tmpvar/jsdom">jsdom</a>. În cazul în care dezvoltați un serviciu nodejs, utilizaţi opţiunea <code>node</code> pentru a folosi un mediu similar cu nodejs.</p>
<p>În cazul în care unele teste necesită un alt mediu, puteţi adăuga blocul <code>@jest-environmen</code>.</p>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<pre><code class="language-js"><span class="hljs-comment">/**
 * @jest-environment jsdom
 */</span>

test(<span class="hljs-string">'use jsdom in this test file'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
  expect(element).not.toBeNull();
});
</code></pre>
<p>You can create your own module that will be used for setting up the test environment. The module must export a class with <code>setup</code>, <code>teardown</code> and <code>runScript</code> methods.</p>
<p><em>Note: TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.</em></p>
<p>Exemplu:</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomEnvironment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NodeEnvironment</span> </span>{
  <span class="hljs-keyword">constructor</span>(config) {
    <span class="hljs-keyword">super</span>(config);
  }

  <span class="hljs-keyword">async</span> setup() {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">super</span>.setup();
    <span class="hljs-keyword">await</span> someSetupTasks();
  }

  <span class="hljs-keyword">async</span> teardown() {
    <span class="hljs-keyword">await</span> someTeardownTasks();
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">super</span>.teardown();
  }

  runScript(script) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.runScript(script);
  }
}
</code></pre>
<h3><a class="anchor" name="testmatch-array-string"></a><code>testMatch</code> [array&lt;string&gt;] <a class="hash-link" href="#testmatch-array-string">#</a></h3>
<h5><a class="anchor" name="disponibil-in-jest-1900"></a>disponibil în Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-1900">#</a></h5>
<p>(implicit: <code>[ '**/__tests__/**/*.js?(x)', '**/?(*.)(spec|test).js?(x)' ]</code>)</p>
<p>Modele glob pe care Jest le utilizează pentru a detecta fişiere de test. În mod implicit, Jest caută fişiere <code>.js</code> şi <code>.jsx</code> în interiorul directorului <code>__tests__</code>, precum şi orice fișier cu sufixul <code>.test</code> sau <code>.spec</code> (de exemplu, <code>Component.test.js</code> sau <code>Component.spec.js</code>). De asemenea, va găsi fişiere denumite <code>test.js</code> sau <code>spec.js</code>.</p>
<p>A se vedea pachetul <a href="https://github.com/jonschlinkert/micromatch"> micromatch</a> pentru detalii de modele pe care le puteţi specifica.</p>
<p>A se vedea, de asemenea, <a href="#testregex-string"> <code>testRegex</code> [string]</a>, dar reţineţi că nu puteţi specifica ambele opţiuni.</p>
<h3><a class="anchor" name="testpathignorepatterns-array-string"></a><code>testPathIgnorePatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#testpathignorepatterns-array-string">#</a></h3>
<p>Implicit: <code>[&quot;/node_modules/&quot;]</code></p>
<p>O serie de expresii regulate care sunt comparate cu toate căile fişierelor înainte de execuția testelor. Fişierele care se potrivesc cu oricare dintre reguli vor fi ignorate.</p>
<p>Aceste reguli sunt comparate față de calea completă. Utilizaţi cuvântul cheie <code>&lt;rootDir&gt;</code> pentru a include calea către directorul rădăcină din proiectul vostru pentru a preveni ignorarea accidentală a fișierelor în medii diferite, care pot avea diferite directoare rădăcină. Exemplu: <code>[&quot;&lt;rootDir&gt;/build/&quot;, &quot;&lt;rootDir&gt;/node_modules/&quot;]</code>.</p>
<h3><a class="anchor" name="testregex-string"></a><code>testRegex</code> [string] <a class="hash-link" href="#testregex-string">#</a></h3>
<p>Implicit: <code>(/__tests__/.*|(\\.|/)(test|spec))\\.jsx?$</code></p>
<p>Modele glob pe care Jest le utilizează pentru a detecta fişiere de test. În mod implicit, Jest caută fişiere <code>.js</code> şi <code>.jsx</code> în interiorul directorului <code>__tests__</code>, precum şi orice fișier cu sufixul <code>.test</code> sau <code>.spec</code> (de exemplu, <code>Component.test.js</code> sau <code>Component.spec.js</code>). De asemenea, va găsi fişiere denumite <code>test.js</code> sau <code>spec.js</code>. A se vedea, de asemenea, <a href="#testmatch-array-string"><code>testMatch</code>[array&lt;string&gt;]</a>, dar reţineţi că nu puteţi specifica ambele opţiuni.</p>
<p>Aceasta este o vizualizare a opțiunii implicite:</p>
<pre><code>├── __tests__
│   └── component.spec.js # test
│   └── anything # test
├── package.json # not test
├── foo.test.js # test
├── bar.spec.jsx # test
└── component.js # not test
</code></pre>
<h3><a class="anchor" name="testresultsprocessor-string"></a><code>testResultsProcessor</code> [string] <a class="hash-link" href="#testresultsprocessor-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</p>
<pre><code>{
  &quot;success&quot;: bool,
  &quot;startTime&quot;: epoch,
  &quot;numTotalTestSuites&quot;: number,
  &quot;numPassedTestSuites&quot;: number,
  &quot;numFailedTestSuites&quot;: number,
  &quot;numRuntimeErrorTestSuites&quot;: number,
  &quot;numTotalTests&quot;: number,
  &quot;numPassedTests&quot;: number,
  &quot;numFailedTests&quot;: number,
  &quot;numPendingTests&quot;: number,
  &quot;testResults&quot;: [{
    &quot;numFailingTests&quot;: number,
    &quot;numPassingTests&quot;: number,
    &quot;numPendingTests&quot;: number,
    &quot;testResults&quot;: [{
      &quot;title&quot;: string (message in it block),
      &quot;status&quot;: &quot;failed&quot; | &quot;pending&quot; | &quot;passed&quot;,
      &quot;ancestorTitles&quot;: [string (message in describe blocks)],
      &quot;failureMessages&quot;: [string],
      &quot;numPassingAsserts&quot;: number
    },
    ...
    ],
    &quot;perfStats&quot;: {
      &quot;start&quot;: epoch,
      &quot;end&quot;: epoch
    },
    &quot;testFilePath&quot;: absolute path to test file,
    &quot;coverage&quot;: {}
  },
  ...
  ]
}
</code></pre>
<h3><a class="anchor" name="testrunner-string"></a><code>testRunner</code> [string] <a class="hash-link" href="#testrunner-string">#</a></h3>
<p>Implicit: <code>jasmine2</code></p>
<p>Această opţiune permite utilizarea unui anumit framework de testare. Implicit este utilizat jasmine2. Un framework de testare personalizat poate fi furnizat prin specificarea unei căi spre implementarea sa.</p>
<p>Un astfel de modul trebuie să exporte o funcţie cu următoarea semnătură:</p>
<pre><code>function testRunner(
  config: Config,
  environment: Environment,
  runtime: Runtime,
  testPath: string,
): Promise&lt;TestResult&gt;
</code></pre>
<p>Un exemplu de astfel de funcţie poate fi găsită în modulul nostru implicit <a href="https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.js">jasmine2</a>.</p>
<h3><a class="anchor" name="testurl-string"></a><code>testURL</code> [string] <a class="hash-link" href="#testurl-string">#</a></h3>
<p>Implicit: <code>about:blank</code></p>
<p>Această opţiune stabileşte URL-ul pentru mediul jsdom. Aceasta apare în diverse proprietăţi, cum ar fi <code>location.href</code>.</p>
<h3><a class="anchor" name="timers-string"></a><code>timers</code> [string] <a class="hash-link" href="#timers-string">#</a></h3>
<p>Implicit: <code>real</code></p>
<p>Setarea acestei valori cu <code>fake</code> permite utilizarea de cronometre false pentru funcţii precum <code>setTimeout</code>. Cronometrele false sunt utile atunci când o bucată de cod stabileşte o pauză lungă pe care nu dorim să o aşteptăm într-un test.</p>
<h3><a class="anchor" name="transform-object-string-string"></a><code>transform</code> [object&lt;string, string&gt;] <a class="hash-link" href="#transform-object-string-string">#</a></h3>
<p>Implicit: <code>undefined</code></p>
<p>O mapare între expresii regulate către căi de transformatoare. Un transformator este un modul care oferă o funcţie sincron pentru transformarea fişierele sursă. De exemplu, dacă vreți să utilizați o nouă caracteristică de limbaj în module sau teste, care nu este suportată deocamdata de nodejs, puteți introduce unul din multele compilatoare care vor compila o versiune viitoare a limbajului JavaScript într-una curentă. Example: see the <a href="https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16">examples/typescript</a> example or the <a href="/jest/docs/ro/webpack.html">webpack tutorial</a>.</p>
<p>Exemple de astfel de compilatoare includ <a href="https://babeljs.io/"> Babel</a>, <a href="http://www.typescriptlang.org/">TypeScript</a> şi <a href="http://github.com/leebyron/async-to-gen#jest">async-to-gen</a>.</p>
<p><em>Notă: un transformator este rulat doar o dată per fişier dacă acesta nu s-a modificat. During development of a transformer it can be useful to run Jest with <code>--no-cache</code> or to frequently <a href="/jest/docs/ro/troubleshooting.html#caching-issues">delete Jest's cache</a>.</em></p>
<p><em>Notă: dacă utilizaţi transformatorul <code>babel-jest</code> şi doriţi să utilizaţi un preprocesor suplimentar de cod, ţineţi minte că atunci când &quot;transform&quot; este suprascris, <code>babel-jest</code> nu mai este încărcat automat. Dacă doriţi să-l utilizaţi pentru a compila codul JavaScript trebuie să fie definit în mod explicit. A se vedea <a href="https://github.com/facebook/jest/tree/master/packages/babel-jest#setup">babel-jest plugin</a></em></p>
<h3><a class="anchor" name="transformignorepatterns-array-string"></a><code>transformIgnorePatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#transformignorepatterns-array-string">#</a></h3>
<p>Implicit: <code>[&quot;/node_modules/&quot;]</code></p>
<p>O serie de expresii regulate care sunt comparate cu toate căile fişierelor înainte de transformare. Pentru toate fişierele care se potrivesc cu oricare dintre reguli, acestea nu vor fi transformate.</p>
<p>Aceste reguli sunt comparate față de calea completă. Utilizaţi cuvântul cheie <code>&lt;rootDir&gt;</code> pentru a include calea către directorul rădăcină din proiectul vostru pentru a preveni ignorarea accidentală a fișierelor în medii diferite, care pot avea diferite directoare rădăcină. Exemplu: <code>[&quot;&lt;rootDir&gt;/bower_components/&quot;, &quot;&lt;rootDir&gt;/node_modules/&quot;]</code>.</p>
<h3><a class="anchor" name="unmockedmodulepathpatterns-array-string"></a><code>unmockedModulePathPatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#unmockedmodulepathpatterns-array-string">#</a></h3>
<p>Implicit: <code>[]</code></p>
<p>O serie de expresii regulate care sunt comparate cu toate modulele inainte sa se returneze o dublare automată a lor. Pentru toate fișierele care se potrivesc cu oricare dintre modele din această listă, acesta nu va fi dublat automat.</p>
<p>Aceasta este utilă pentru unele module 'utilitare' frecvente, care sunt aproape întotdeauna utilizate ca detalii de implementare (cum ar fi underscore/lo-dash, etc). În general este o bună practică pentru a păstra această listă cât mai scurtă posibil şi folosirea explicită a <code>jest.mock()</code> / <code>jest.unmock()</code> în teste individuale. Configurare explicită per test este mult mai uşoară pentru alţi cititori ai testului privind înțelegerea mediului în care va rula testul.</p>
<p>Este posibilă suprascrierea aceastei setări în teste individuale prin apelul explicit <code>jest.mock()</code> în partea de sus a fişierului de testare.</p>
<h3><a class="anchor" name="verbose-boolean"></a><code>verbose</code> [boolean] <a class="hash-link" href="#verbose-boolean">#</a></h3>
<p>Implicit: <code>false</code></p>
<p>Indică dacă fiecare test individual ar trebui să fie raportat în timpul executării. Toate erorile vor fi oricum indicate la final, după execuție.</p>
<h3><a class="anchor" name="watchpathignorepatterns-array-string"></a><code>watchPathIgnorePatterns</code> [array&lt;string&gt;] <a class="hash-link" href="#watchpathignorepatterns-array-string">#</a></h3>
<p>Implicit: <code>[]</code></p>
<h5><a class="anchor" name="disponibil-in-jest-2100"></a>disponibil în Jest <strong>21.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2100">#</a></h5>
<p>O listă de tipare RegExp care sunt comparate cu toate căile fişierelor sursă înainte de a re-rula testele în modul de veghe. În cazul în care calea de fişier se potriveşte cu oricare dintre modele, atunci când acesta este actualizat, nu se va declanşa o re-rulare a testelor.</p>
<p>Aceste tipare sunt comparate față de calea completă. Utilizaţi cuvântul cheie <code>&lt;rootDir&gt;</code> pentru a include calea către directorul rădăcină din proiectul vostru pentru a preveni ignorarea accidentală a fișierelor în medii diferite, care pot avea diferite directoare rădăcină. Exemplu: <code>[&quot;&lt;rootDir&gt;/node_modules/&quot;]</code>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="jest-object.html">← The Jest Object</a><a class="docs-next button" href="cli.html">Jest CLI Options →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ro/getting-started.html">Getting Started</a><a href="/jest/docs/ro/snapshot-testing.html">Guides</a><a href="/jest/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ro/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>