<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Globals · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Globals · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="În fişierele de test, Jest atașează fiecare dintre aceste metode şi obiecte la nivel global. Nu aveţi nevoie să importați nimic pentru a le putea folosi."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ro/getting-started.html" target="_self">Documentație</a></li><li><a href="/jest/docs/ro/api.html" target="_self">API</a></li><li><a href="/jest/ro/help.html" target="_self">Ajutor</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ro/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/snapshot-testing.html">Testarea de imagine</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Globals</h1></header><article><div><span><p>În fişierele de test, Jest atașează fiecare dintre aceste metode şi obiecte la nivel global. Nu aveţi nevoie să importați nimic pentru a le putea folosi.</p>
<h2><a class="anchor" name="metode"></a>Metode <a class="hash-link" href="#metode">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referin-e"></a>Referințe <a class="hash-link" href="#referin-e">#</a></h2>
<h3><a class="anchor" name="afterallfn"></a><code>afterAll(fn)</code> <a class="hash-link" href="#afterallfn">#</a></h3>
<p>Execută o funcţie după finalizarea tuturor testelor din fișier. În cazul în care funcţia returnează un Promise, Jest aşteaptă ca Promise-ul să se rezolve înainte de a continua.</p>
<p>Acest lucru este adesea util dacă doriţi să curăţați unele configurări globale, care este utilizate între diferite teste.</p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Aici <code>afterAll</code> asigură că <code>cleanUpDatabase</code> este apelată după execuția tuturor testelor.</p>
<p>În cazul în care <code>afterAll</code> este în interiorul unui bloc <code>describe</code>, se va executa la sfârşitul blocului.</p>
<p>Dacă doriţi să rulaţi ceva logică de curățare după fiecare test, nu după toate testele, se poate utiliza <code>afterEach</code> în schimb.</p>
<h3><a class="anchor" name="aftereachfn"></a><code>afterEach(fn)</code> <a class="hash-link" href="#aftereachfn">#</a></h3>
<p>Execută o funcţie după finalizarea fiecărui test din fișier. În cazul în care funcţia returnează un Promise, Jest aşteaptă ca Promise-ul să se rezolve înainte de a continua.</p>
<p>Acest lucru este adesea util dacă doriţi să curăţați unele configurări temporare, care sunt create în fiecare test.</p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Aici <code>afterEach</code> asigură că <code>cleanUpDatabase</code> este apelată după execuția fiecărui test în parte.</p>
<p>În cazul în care <code>afterEach</code> este în interiorul unui bloc <code>describe</code>, se va executa doar după fiecare test din interiorul blocului.</p>
<p>Dacă doriţi să rulaţi ceva logică de curățare doar o singură dată, după execuția tuturor testelor, utilizaţi <code>afterAll</code> în schimb.</p>
<h3><a class="anchor" name="beforeallfn"></a><code>beforeAll(fn)</code> <a class="hash-link" href="#beforeallfn">#</a></h3>
<p>Execută o funcţie înainte de orice test din fișier. În cazul în care funcţia returnează un Promise, Jest aşteaptă ca Promise-ul să se rezolve înainte de a rula testele.</p>
<p>Acest lucru este adesea util dacă doriţi să setați unele configurări globale, care vor fi utilizate de mai multe teste.</p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

<span class="hljs-comment">// Since we only set up the database once in this example, it's important</span>
<span class="hljs-comment">// that our tests don't modify it.</span>
test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});
</code></pre>
<p>Aici <code>beforeAll</code> asigură că baza de date este setată înainte de a rula testele. Dacă programul de instalare ar fi fost sincron, se putea face acest lucru și fără <code>beforeAll</code>. Cheia este că Jest va aştepta pentru un Promise să se rezolve, astfel încât puteţi avea o configurare asincronă, de asemenea.</p>
<p>În cazul în care <code>beforeAll</code> este în interiorul unui bloc <code>describe</code>, se va executa la începutul blocului.</p>
<p>Dacă doriţi să rulaţi ceva logică înaintea fiecărui test, nu înainte de toate testele, se poate utiliza <code>beforeEach</code> în schimb.</p>
<h3><a class="anchor" name="beforeeachfn"></a><code>beforeEach(fn)</code> <a class="hash-link" href="#beforeeachfn">#</a></h3>
<p>Execută o funcţie înainte de fiecare test din fișier. În cazul în care funcţia returnează un Promise, Jest aşteaptă ca Promise-ul să se rezolve înainte de a rula testele.</p>
<p>Acest lucru este adesea util dacă doriţi să resetați unele configurări globale, care vor fi utilizate de mai multe teste.</p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Aici <code>beforeEach</code> asigură că baza de date este resetată înainte de fiecare test.</p>
<p>În cazul în care <code>beforeEach</code> este în interiorul unui bloc <code>describe</code>, se va executa înainte de fiecare test din interiorul blocului.</p>
<p>Dacă aveţi nevoie doar să rulați ceva cod de configurare o singură dată, înainte de orice test, utilizaţi <code>beforeAll</code>.</p>
<h3><a class="anchor" name="describename-fn"></a><code>describe(name, fn)</code> <a class="hash-link" href="#describename-fn">#</a></h3>
<p><code>describe(name, fn)</code> creează un bloc care grupează mai multe teste într-o &quot;suită de teste&quot;. De exemplu, dacă aveţi un obiect <code>myBeverage</code>, care se presupune a fi delicios, dar nu acru, aţi putea test acest lucru în felul următor:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myBeverage = {
  <span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>,
};

describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});
</code></pre>
<p>Acest lucru nu este necesar - se pot scrie doar blocurile <code>test</code> direct la nivelul de sus. Însă acest lucru poate fi la îndemână dacă preferaţi ca testele să fie organizate în grupe.</p>
<p>Puteţi, de asemenea, imbrica blocuri <code>describe</code> în cazul în care aveţi o ierarhie de teste:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> binaryStringToNumber = <span class="hljs-function"><span class="hljs-params">binString</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[01]+$/</span>.test(binString)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'Not a binary number.'</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(binString, <span class="hljs-number">2</span>);
};

describe(<span class="hljs-string">'binaryStringToNumber'</span>, () =&gt; {
  describe(<span class="hljs-string">'given an invalid binary string'</span>, () =&gt; {
    test(<span class="hljs-string">'composed of non-numbers throws CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> binaryStringToNumber(<span class="hljs-string">'abc'</span>)).toThrowError(CustomError);
    });

    test(<span class="hljs-string">'with extra whitespace throws CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> binaryStringToNumber(<span class="hljs-string">'  100'</span>)).toThrowError(CustomError);
    });
  });

  describe(<span class="hljs-string">'given a valid binary string'</span>, () =&gt; {
    test(<span class="hljs-string">'returns the correct number'</span>, () =&gt; {
      expect(binaryStringToNumber(<span class="hljs-string">'100'</span>)).toBe(<span class="hljs-number">4</span>);
    });
  });
});
</code></pre>
<h3><a class="anchor" name="describeonlyname-fn"></a><code>describe.only(name, fn)</code> <a class="hash-link" href="#describeonlyname-fn">#</a></h3>
<p>Există și cu aliasul: <code>fdescribe(name, fn)</code></p>
<p>Aveţi posibilitatea să utilizaţi <code>describe.only</code> dacă doriţi să se execute un singur bloc describe:</p>
<pre><code class="language-js">describe.only(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe(<span class="hljs-string">'my other beverage'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<h3><a class="anchor" name="describeskipname-fn"></a><code>describe.skip(name, fn)</code> <a class="hash-link" href="#describeskipname-fn">#</a></h3>
<p>Există și cu aliasul: <code>xdescribe(name, fn)</code></p>
<p>Aveţi posibilitatea să utilizaţi <code>describe.skip</code> dacă nu doriţi să se execute un anumit bloc describe:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe.skip(<span class="hljs-string">'my other beverage'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<p>Folosirea <code>describe.skip</code> este adesea doar o alternativă mai simplă pentru comentarea temporară a unui bloc describe.</p>
<h3><a class="anchor" name="requirerequireactualmodulename"></a><code>require.requireActual(moduleName)</code> <a class="hash-link" href="#requirerequireactualmodulename">#</a></h3>
<p>Returnează modulul efectiv în locul unei dubluri, ocolind toate verificările dacă modulul respectiv ar trebui să fie mock-uit sau nu.</p>
<h3><a class="anchor" name="requirerequiremockmodulename"></a><code>require.requireMock(moduleName)</code> <a class="hash-link" href="#requirerequiremockmodulename">#</a></h3>
<p>Returnează o dublură în locul modulului real, ocolind toate verificările dacă modulul respectiv ar trebui să fie mock-uit sau nu.</p>
<h3><a class="anchor" name="testname-fn"></a><code>test(name, fn)</code> <a class="hash-link" href="#testname-fn">#</a></h3>
<p>Există și cu aliasul: <code>it(name, fn)</code></p>
<p>Tot ce ai nevoie într-un fişier de test este metoda <code>test</code>, care execută un test. De exemplu, să presupunem că există o funcţie <code>inchesOfRain()</code>, care ar trebui să fie zero. Întregul test ar putea fi:</p>
<pre><code class="language-js">test(<span class="hljs-string">'did not rain'</span>, () =&gt; {
  expect(inchesOfRain()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Primul argument este numele testului; al doilea argument este o funcţie care conţine aserțiunile pentru test.</p>
<blockquote>
<p>Notă: În cazul în care o <strong>promisiune este returnată</strong> din <code>test</code>, Jest va aştepta rezolvarea promisiunii înainte ca testul să se finalizeze. Jest va aştepta, de asemenea, și dacă <strong>pasați un argument la funcţia de test</strong>, numit de obicei <code>done</code>. Acest lucru ar putea fi util atunci când testați callback-uri. See how to test async code <a href="/jest/docs/ro/asynchronous.html#callbacks">here</a>.</p>
</blockquote>
<p>De exemplu, să presupunem că <code>fetchBeverageList()</code> returnează o promisiune care ar trebui să rezolve cu o listă care conține o <code>lămâie</code>. Puteți testa acest lucru cu:</p>
<pre><code class="language-js">test(<span class="hljs-string">'has lemon in it'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> fetchBeverageList().then(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> {
    expect(list).toContain(<span class="hljs-string">'lemon'</span>);
  });
});
</code></pre>
<p>Chiar dacă apelul pentru <code>test</code> va returna imediat, testul nu se va finaliza doar după rezolvarea promisiunii.</p>
<h3><a class="anchor" name="testonlyname-fn"></a><code>test.only(name, fn)</code> <a class="hash-link" href="#testonlyname-fn">#</a></h3>
<p>De asemenea, sub aliasurile: <code>it.only(nume, fn)</code> sau <code>fit(nume, fn)</code></p>
<p>Atunci când depanați baze mari de cod, veţi dori să rulași doar un subset de teste. Utilizaţi <code>.only</code> să specificați care sunt testele ce doriţi să se ruleze.</p>
<p>De exemplu, să presupunem că aveți aceste teste:</p>
<pre><code class="language-js">test.only(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Doar testul &quot;it is raining&quot; va rula, deoarece acesta este apelat cu <code>test.only</code>.</p>
<p>De obicei nu veți adăuga teste cu <code>test.only</code> în sistemul de versionare - ar trebui folosit doar pentru depanare, şi scos de îndată ce testele stricate au fost reparate.</p>
<h3><a class="anchor" name="testskipname-fn"></a><code>test.skip(name, fn)</code> <a class="hash-link" href="#testskipname-fn">#</a></h3>
<p>De asemenea, sub aliasurile: <code>it.skip(nume, fn)</code> sau <code>xit(nume, fn)</code> sau <code>xtest(nume, fn)</code></p>
<p>Atunci când lucrați cu baze mari de cod, puteţi găsi, uneori, un test care este temporar stricat din diverse motive. Dacă doriţi să săriţi peste rulearea acestui test, dar nu doriţi să-l ştergeţi, utilizaţi <code>test.skip</code> pentru a specifica testele peste care să se sară.</p>
<p>De exemplu, să presupunem că aveți aceste teste:</p>
<pre><code class="language-js">test(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test.skip(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Doar testul &quot;it is raining&quot; va rula, deoarece celălalt test este apelat cu <code>test.skip</code>.</p>
<p>Puteți comenta pur şi simplu testul, însă este de multe mai la îndemână utilizarea <code>test.skip</code>, deoarece se va menţine indentarea şi evidențierea sintaxei.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="more-resources.html">← More Resources</a><a class="docs-next button" href="expect.html">Expect →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ro/getting-started.html">Getting Started</a><a href="/jest/docs/ro/snapshot-testing.html">Guides</a><a href="/jest/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ro/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>