<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Mock Functions · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Mock Functions · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Funcţiile mock sunt, de asemenea, cunoscute și ca &quot;spioni&quot;, deoarece acestea vă permit să spionați comportamentul unei funcţii care este apelată indirect de alt cod, decât să testăm doar datele de ieşire. Puteți crea o funcţie mock cu `jest.fn()`. În cazul în care nu este specificată o implementare, funcţia mock va returna `undefined` când este apelată."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ro/getting-started.html" target="_self">Documentație</a></li><li><a href="/jest/docs/ro/api.html" target="_self">API</a></li><li><a href="/jest/ro/help.html" target="_self">Ajutor</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/expect.html">Expect</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ro/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/snapshot-testing.html">Testarea de imagine</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Mock Functions</h1></header><article><div><span><p>Funcţiile mock sunt, de asemenea, cunoscute și ca &quot;spioni&quot;, deoarece acestea vă permit să spionați comportamentul unei funcţii care este apelată indirect de alt cod, decât să testăm doar datele de ieşire. Puteți crea o funcţie mock cu <code>jest.fn()</code>. În cazul în care nu este specificată o implementare, funcţia mock va returna <code>undefined</code> când este apelată.</p>
<h2><a class="anchor" name="metode"></a>Metode <a class="hash-link" href="#metode">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referin-e"></a>Referințe <a class="hash-link" href="#referin-e">#</a></h2>
<h3><a class="anchor" name="mockfngetmockname"></a><code>mockFn.getMockName()</code> <a class="hash-link" href="#mockfngetmockname">#</a></h3>
<h5><a class="anchor" name="available-in-jest-2130"></a>available in Jest <strong>21.3.0+</strong> <a class="hash-link" href="#available-in-jest-2130">#</a></h5>
<p>Returns the mock name string set by calling <code>mockFn.mockName(value)</code>.</p>
<h3><a class="anchor" name="mockfnmockcalls"></a><code>mockFn.mock.calls</code> <a class="hash-link" href="#mockfnmockcalls">#</a></h3>
<p>O listă care reprezintă toate apelurile care au fost făcute la această funcţie mock. Fiecare apel este reprezentat de o serie de argumente care au fost pasate în timpul apelului.</p>
<p>De exemplu: un funcţie mock <code>f</code>, care a fost apelată de două ori, cu argumentele <code>f ('arg1', 'arg2')</code>, şi apoi cu argumentele <code>f ('arg3', 'arg4')</code> ar avea un array <code>mock.calls</code> care arată în felul următor:</p>
<pre><code class="language-js">[
  [<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>],
  [<span class="hljs-string">'arg3'</span>, <span class="hljs-string">'arg4'</span>],
];
</code></pre>
<h3><a class="anchor" name="mockfnmockinstances"></a><code>mockFn.mock.instances</code> <a class="hash-link" href="#mockfnmockinstances">#</a></h3>
<p>Un array care conţine toate instanţele obiectelor instanţiate din această funcţie mock, folosind <code>new</code>.</p>
<p>De exemplu: O funcţie mock, care a fost instanţiată de două ori ar avea array-ul <code>mock.instances</code> următor:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn();

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> mockFn();
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> mockFn();

mockFn.mock.instances[<span class="hljs-number">0</span>] === a; <span class="hljs-comment">// true</span>
mockFn.mock.instances[<span class="hljs-number">1</span>] === b; <span class="hljs-comment">// true</span>
</code></pre>
<h3><a class="anchor" name="mockfnmockclear"></a><code>mockFn.mockClear()</code> <a class="hash-link" href="#mockfnmockclear">#</a></h3>
<p>Resetează toate informaţiile stocate în array-urile <a href="#mockfn-mock-calls"> <code>mockFn.mock.calls</code></a> şi <a href="#mockfn-mock-instances"> <code>mockFn.mock.instances</code></a>.</p>
<p>Acest lucru este util atunci când doriţi să curăţați datele unui mock între două aserțiuni.</p>
<p>Țineți cont că <code>mockClear</code> va înlocui <code>mockFn.mock</code>, nu doar <a href="#mockfn-mock-calls"> <code>mockFn.mock.calls</code></a> şi <a href="#mockfn-mock-instances"> <code>mockFn.mock.instances</code></a>. Așadar, ar trebui să evitați atribuirea lui <code>mockFn.mock</code> altei variabile, temporare sau nu, pentru a vă asigura că nu accesaţi date vechi.</p>
<p>Opţiunea de configurare <a href="configuration.html#clearmocks-boolean"> <code>clearMocks</code></a> este disponibilă pentru a curăța automat mock-urile între teste.</p>
<h3><a class="anchor" name="mockfnmockreset"></a><code>mockFn.mockReset()</code> <a class="hash-link" href="#mockfnmockreset">#</a></h3>
<p>Resets all information stored in the mock, including any initial implementation and mock name given.</p>
<p>Acest lucru este util atunci când doriţi să restauraţi complet un mock înapoi la starea sa iniţială.</p>
<p>Țineți cont că <code>mockReset</code> va înlocui <code>mockFn.mock</code>, nu doar <a href="#mockfn-mock-calls"> <code>mockFn.mock.calls</code></a> şi <a href="#mockfn-mock-instances"> <code>mockFn.mock.instances</code></a>. Așadar, ar trebui să evitați atribuirea lui <code>mockFn.mock</code> altei variabile, temporare sau nu, pentru a vă asigura că nu accesaţi date vechi.</p>
<h3><a class="anchor" name="mockfnmockrestore"></a><code>mockFn.mockRestore()</code> <a class="hash-link" href="#mockfnmockrestore">#</a></h3>
<p>Elimină mock-ul şi restabileşte implementarea iniţială.</p>
<p>Acest lucru este util atunci când vreți să dublați funcţii în anumite cazuri de testare şi să restabiliți implementarea originală în altele.</p>
<p>Țineți cont că <code>mockFn.mockRestore</code> funcţionează numai atunci când mock-ul a fost creat cu <code>jest.spyOn</code>. Așadar trebuie să faceți voi curățarea atunci când folosiți <code>jest.fn()</code>.</p>
<h3><a class="anchor" name="mockfnmockimplementationfn"></a><code>mockFn.mockImplementation(fn)</code> <a class="hash-link" href="#mockfnmockimplementationfn">#</a></h3>
<p>Acceptă o funcţie care va fi folosită ca implementare a mock-ului. Mock în sine va înregistra în continuare toate apelurile și instanțierile – singura diferenţă este că implementarea va fi executată și ea când este apelat mock-ul.</p>
<p><em>Notă: <code>jest.fn(implementare)</code> este o prescurtare pentru <code>jest.fn().mockImplementation(implementare)</code>.</em></p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">scalar</span> =&gt;</span> <span class="hljs-number">42</span> + scalar);
<span class="hljs-comment">// or: jest.fn(scalar =&gt; 42 + scalar);</span>

<span class="hljs-keyword">const</span> a = mockFn(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> b = mockFn(<span class="hljs-number">1</span>);

a === <span class="hljs-number">42</span>; <span class="hljs-comment">// true</span>
b === <span class="hljs-number">43</span>; <span class="hljs-comment">// true</span>

mockFn.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
mockFn.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>
</code></pre>
<p><code>mockImplementation</code> poate fi folosit și pentru dublarea constructorilor de clase:</p>
<pre><code>// SomeClass.js
module.exports = class SomeClass {
  m(a, b) {}
}

// OtherModule.test.js
jest.mock('./SomeClass');  // this happens automatically with automocking
const SomeClass = require('./SomeClass')
const mMock = jest.fn()
SomeClass.mockImplementation(() =&gt; {
  return {
    m: mMock
  }
})

const some = new SomeClass()
some.m('a', 'b')
console.log('Calls to m: ', mMock.mock.calls)
</code></pre>
<h3><a class="anchor" name="mockfnmockimplementationoncefn"></a><code>mockFn.mockImplementationOnce(fn)</code> <a class="hash-link" href="#mockfnmockimplementationoncefn">#</a></h3>
<p>Acceptă o funcţie care va fi utilizată ca implementare a mock-ului pentru un singur apel. Poate fi înlănțuită astfel încât mai multe apelări succesive vor produce rezultate diferite.</p>
<pre><code>var myMockFn = jest.fn()
  .mockImplementationOnce(cb =&gt; cb(null, true))
  .mockImplementationOnce(cb =&gt; cb(null, false));

myMockFn((err, val) =&gt; console.log(val));
&gt; true

myMockFn((err, val) =&gt; console.log(val));
&gt; false
</code></pre>
<p>Atunci când funcţia mock rămâne fără implementări definite cu mockImplementationOnce, se va executa implementarea implicită cu <code>jest.fn(() = &gt; valoare-implicită)</code> sau <code>.mockImplementation(() = &gt; valoare-implicită)</code> dacă acestea au fost definite:</p>
<pre><code>var myMockFn = jest.fn(() =&gt; 'default')
  .mockImplementationOnce(() =&gt; 'first call')
  .mockImplementationOnce(() =&gt; 'second call');

console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
&gt; 'first call', 'second call', 'default', 'default'
</code></pre>
<h3><a class="anchor" name="mockfnmocknamevalue"></a><code>mockFn.mockName(value)</code> <a class="hash-link" href="#mockfnmocknamevalue">#</a></h3>
<h5><a class="anchor" name="available-in-jest-2130"></a>available in Jest <strong>21.3.0+</strong> <a class="hash-link" href="#available-in-jest-2130">#</a></h5>
<p>Accepts a string to use in test result output in place of &quot;jest.fn()&quot; to indicate which mock function is being referenced.</p>
<p>De exemplu:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn().mockName(<span class="hljs-string">'mockedFunction'</span>);
<span class="hljs-comment">// mockFn();</span>
expect(mockFn).toHaveBeenCalled();
</code></pre>
<p>Will result in this error:</p>
<pre><code>    expect(mockedFunction).toHaveBeenCalled()

    Expected mock function to have been called.
</code></pre>
<h3><a class="anchor" name="mockfnmockreturnthis"></a><code>mockFn.mockReturnThis()</code> <a class="hash-link" href="#mockfnmockreturnthis">#</a></h3>
<p>Doar o metodă simplificată pentru:</p>
<pre><code class="language-js">jest.fn(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
});
</code></pre>
<h3><a class="anchor" name="mockfnmockreturnvaluevalue"></a><code>mockFn.mockReturnValue(value)</code> <a class="hash-link" href="#mockfnmockreturnvaluevalue">#</a></h3>
<p>Acceptă o valoare ce va fi returnată ori de câte ori se apelează funcţia mock.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mock = jest.fn();
mock.mockReturnValue(<span class="hljs-number">42</span>);
mock(); <span class="hljs-comment">// 42</span>
mock.mockReturnValue(<span class="hljs-number">43</span>);
mock(); <span class="hljs-comment">// 43</span>
</code></pre>
<h3><a class="anchor" name="mockfnmockreturnvalueoncevalue"></a><code>mockFn.mockReturnValueOnce(value)</code> <a class="hash-link" href="#mockfnmockreturnvalueoncevalue">#</a></h3>
<p>Acceptă o valoare ce va fi returnată pentru un singur apel al funcţiei mock. Poate fi înlănțuită astfel încât apeluri succesive ale funcţiei mock vor returna valori diferite. Atunci când nu mai există valori <code>mockReturnValueOnce</code> rămase, apelurile următoare vor returna valoarea specificată de <code>mockReturnValue</code>.</p>
<pre><code>const myMockFn = jest.fn()
  .mockReturnValue('implicit')
  .mockReturnValueOnce('primul apel')
  .mockReturnValueOnce('al doilea apel');

console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
&gt; 'primul apel', 'al doilea apel', 'implicit', 'implicit'</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="expect.html">← Expect</a><a class="docs-next button" href="jest-object.html">The Jest Object →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ro/getting-started.html">Getting Started</a><a href="/jest/docs/ro/snapshot-testing.html">Guides</a><a href="/jest/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ro/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>