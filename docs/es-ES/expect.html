<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Cuando usted escribe pruebas, suele ser necesario revisar que los valores mantengan ciertas condiciones. `expect` le da acceso a un número de “correspondencias” que le permite validar diferentes aspectos."/><meta property="og:image" content="https://facebook.github.io/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/jest/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/es-ES/getting-started.html" target="_self">Documentación</a></li><li><a href="/jest/docs/es-ES/api.html" target="_self">API</a></li><li><a href="/jest/es-ES/help.html" target="_self">Ayuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/jest-platform.html">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/es6-class-mocks.html">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/puppeteer.html">
Usar con puppeteer</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mongodb.html">Utilizando con MongoDB</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/troubleshooting.html">Troubleshooting</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/es-ES/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/cli.html">Jest CLI Options</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/ExpectAPI.md" target="_blank">Edit</a><h1>Expect</h1></header><article><div><span><p>Cuando usted escribe pruebas, suele ser necesario revisar que los valores mantengan ciertas condiciones. <code>expect</code> le da acceso a un número de “correspondencias” que le permite validar diferentes aspectos.</p>
<h2><a class="anchor" aria-hidden="true" name="metodos"></a><a href="#metodos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Métodos</h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" aria-hidden="true" name="referencia"></a><a href="#referencia" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referencia</h2>
<h3><a class="anchor" aria-hidden="true" name="expectvalue"></a><a href="#expectvalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect(value)</code></h3>
<p>La función <code>expect</code> se utiliza cada vez que desea testear un valor. Rara vez llamarás <code>expect</code> por si mismo. En lugar de esto, utilizará <code>expect</code> junto a una función &quot;matcher&quot; para afirmar algo sobre el valor.</p>
<p>Es más fácil entenderlo con este ejemplo. Digamos que tiene un método <code>bestLaCroixFlavor()</code> el cual, se supone, arrojará la cuerda <code>'grapefruit'</code>. Así es cómo sería el test:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'el mejor sabor es de melocotón'</span>, () =&gt; {
  expect(mejorSabor()).toBe(<span class="hljs-string">'melocotón'</span>);
});
</code></pre>
<p>En este caso, <code>toBe</code> es la función comparadora. Hay muchas funciones comparadoras diferentes, documentadas más abajo, para dejarle probar diferentes cosas.</p>
<p>El argumento a <code>expect</code> debería ser el valor que su código produzca, y cualquier argumento para el comparador debería ser el valor correcto. Si los mezcla, sus pruebas aún funcionarán, pero los mensajes de error en las pruebas que fallen se verán extraños.</p>
<h3><a class="anchor" aria-hidden="true" name="expectextendmatchers"></a><a href="#expectextendmatchers" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.extend(matchers)</code></h3>
<p>Puedes utilizar <code>expect.extend</code> para añadir tus propios comparadores a Jest. Por ejemplo, supongamos que usted está testeando una biblioteca de teoría de números y afirma frecuentemente que los números son divisibles por otros números. Puede extraer eso a un comparador <code>toBeDivisibleBy</code>:</p>
<pre><code class="hljs css js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = received % argument == <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Los comparadores deben devolver un objeto con dos parámetros. <code>pass</code> indica si hay o no hay coincidencia, y <code>message</code> proporciona una función sin argumentos que arroja un mensaje de error en caso de fallo. De esta forma, cuando <code>pass</code> resulta falso, <code>message</code> debería arrojar un mensaje de error para cuando <code>expect(x).yourMatcher()</code> falla. Y cuando <code>pass</code> resulta verdadero, <code>message</code> debería arrojar el mensaje de error para cuando <code>expect(x).not.yourMatcher()</code> falla.</p>
<p>Éstas funciones auxiliares se pueden encontrar dentro de <code>this</code> como comparador personalizado:</p>
<h4><a class="anchor" aria-hidden="true" name="thisisnot"></a><a href="#thisisnot" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.isNot</code></h4>
<p>Un boolean para dejarle saber que esta correspondencia fue llamada con el modificador invalidado <code>.not</code> permitiéndole invertir su afirmación.</p>
<h4><a class="anchor" aria-hidden="true" name="thisequalsa-b"></a><a href="#thisequalsa-b" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.equals(a, b)</code></h4>
<p>Esta es una función de equidad que retornará <code>true</code> si dos objetos tienen el mismo valor (recurrentemente).</p>
<h4><a class="anchor" aria-hidden="true" name="thisutils"></a><a href="#thisutils" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.utils</code></h4>
<p>Existen un número de herramientas útiles expuestas en <code>this.utils</code> consistiendo principalemente de los resultados de <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Lo más útiles son <code>matcherHint</code>, <code>printExpected</code> y <code>printReceived</code> para formatear los mensajes de error apropiadamente. Por ejemplo, echa un vistazo a la implementación para el comparador <code>toBe</code>:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = <span class="hljs-built_in">Object</span>.is(received, expected);

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) +
          <span class="hljs-string">'\n\n'</span> +
          <span class="hljs-string">`Expected value to not be (using Object.is):\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
          <span class="hljs-string">`Received:\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
            <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
          });
          <span class="hljs-keyword">return</span> (
            <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) +
            <span class="hljs-string">'\n\n'</span> +
            <span class="hljs-string">`Expected value to be (using Object.is):\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
            <span class="hljs-string">`Received:\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
            (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>)
          );
        };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Esto mostrará algo así:</p>
<pre><code class="hljs css bash">  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      <span class="hljs-string">"banana"</span>
    Received:
      <span class="hljs-string">"apple"</span>
</code></pre>
<p>Cuando falla la afirmación, los mensajes de error deberían aportar la señal sea necesaria al usuario para que estas puedan resolver su problema rápidamente. Debe elaborar un mensaje de error preciso para asegurarse de que los usuarios de sus afirmaciones modificadas tengan una buena experiencia de desarrollador.</p>
<h3><a class="anchor" aria-hidden="true" name="expectanything"></a><a href="#expectanything" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.anything()</code></h3>
<p><code>expect.anything()</code> aprobará cualquier cosa excepto <code>null</code> o <code>undefined</code>. Puede usarlo adentro de inside <code>toEqual</code> o <code>toBeCalledWith</code> en lugar de un valor literal. Por ejemplo, si desea verificar que una función de simulación es llamada con un argumento no nulo:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectanyconstructor"></a><a href="#expectanyconstructor" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.any(constructor)</code></h3>
<p><code>expect.any(constructor)</code> compara cualquier cosa que haya sido creada con el constructor dado. Puede usarlo dentro de <code>toEqual</code> o <code>toBeCalledWith</code> en lugar de un valor literal. Por ejemplo, si desea controlar que se denomina una función de prueba con un número:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectarraycontainingarray"></a><a href="#expectarraycontainingarray" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.arrayContaining(array)</code></h3>
<p><code>expect.arrayContaining(array)</code> compara un arreglo recibido que contenga todos los elementos en el arreglo esperado. That is, the expected array is a <strong>subset</strong> of the received array. Por esta razón, combina con una matriz recibida que consta con elementos <strong>not</strong> en la matriz esperada.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<pre><code class="hljs css js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectassertionsnumber"></a><a href="#expectassertionsnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.assertions(number)</code></h3>
<p><code>expect.assertions(number)</code> verifica que un cierto número de afirmaciones son llamadas durante la prueba. Esto es útil frecuentemente cuando se prueba el código asíncrono con el fin de asegurarnos de que las aserciones en una devolución de llamada realmente se invocaron.</p>
<p>Por ejemplo, digamos que tenemos una función <code>doAsync</code> que recibe dos callbacks <code>callback1</code> and <code>callback2</code>, llamará a ambas asincrónicamente en un orden desconocido. Podemos comprobarlo con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'doAsync llama a ambos callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>La llamada de <code>expect.assertions(2)</code> asegura que ambas devoluciones de llamada son efectivamente ejecutadas.</p>
<h3><a class="anchor" aria-hidden="true" name="expecthasassertions"></a><a href="#expecthasassertions" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.hasAssertions()</code></h3>
<p><code>expect.hasAssertions()</code> verifica que al menos una afirmación es llamada durante una prueba. Esto es útil cuando se prueba código asincrónico, para poder segurar que las afirmaciones en un callback fueron de hecho llamadas.</p>
<p>Por ejemplo, digamos que tenemos unas pocas funciones y todas tratan con un estado. <code>prepareState</code> llama a un callback con un objeto de estado, <code>validateState</code> ejecuta en ese objeto de estado y <code>waitOnState</code> arroja una promesa que espera hasta que se completen todos los callbacks <code>prepareState</code>. Podemos comprobarlo con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'prepareState prepara un estado valido'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(estado)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>La llamada <code>expect.hasAssertions()</code> se segura de que el callback <code>prepareState</code> sea realmente llamado.</p>
<h3><a class="anchor" aria-hidden="true" name="expectobjectcontainingobject"></a><a href="#expectobjectcontainingobject" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.objectContaining(object)</code></h3>
<p><code>expect.objectContaining(object)</code> compara cualquier objeto recibido que compare recursivamente a las propiedades esperadas. That is, the expected object is a <strong>subset</strong> of the received object. Por lo tanto, coincide con un objeto aceptado que contiene propiedades que ** not ** en el objeto esperado.</p>
<p>En lugar de valores de propiedad literales en el objeto esperado, puede utilizar los comparadores,<code>expect.anything()</code>, y así sucesivamente.</p>
<p>Por ejemplo, digamos que esperamos que sea llamada una función <code>onPress</code> con un objeto <code>Event</code>, y todo lo que queremos verificar es que el evento tenga <code>event.x</code> y propiedades <code>event.y</code>. Puedes hacer esto con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
      <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
    }),
  );
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectstringcontainingstring"></a><a href="#expectstringcontainingstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringContaining(string)</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-1900"></a><a href="#disponible-en-jest-1900" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>19.0.0+</strong></h5>
<p><code>expect.stringContaining(string)</code> coincide cualquier cuerda recibida que contenga exactamente la cuerda esperada.</p>
<h3><a class="anchor" aria-hidden="true" name="expectstringmatchingregexp"></a><a href="#expectstringmatchingregexp" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringMatching(regexp)</code></h3>
<p><code>expect.stringMatching(regexp)</code> compara cualquier cuerda recibida que coincida con el regexp esperado.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para que coincida con un elemento en <code>arrayContaining</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<p>Este ejemplo también muestra como puede anidar multiples comparadores asimétricos, con <code>expect.stringMatching</code> adentro de <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectaddsnapshotserializerserializer"></a><a href="#expectaddsnapshotserializerserializer" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.addSnapshotSerializer(serializer)</code></h3>
<p>Puede llamar <code>expect.addSnapshotSerializer</code> para añadir un módulo que formatee las estructura de datos de aplicaciones específicas.</p>
<p>For an individual test file, an added module precedes any modules from <code>snapshotSerializers</code> configuration, which precede the default snapshot serializers for built-in JavaScript types and for React elements. El último módulo añadido es el primer módulo en ser probado.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test</span>
</code></pre>
<p>Si añade un serializador de snapshot en archivos de prueba individuales en lugar de añadirlo a configuración de <code>snapshotSerializers</code>:</p>
<ul>
<li>Haces la dependencia explícita en lugar de implícita.</li>
<li>Evita los limites de configuración que podrían hacer que se expulse de <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>Ver <a href="/jest/docs/es-ES/configuration.html#snapshotserializers-array-string">configuring Jest</a> para mas información.</p>
<h3><a class="anchor" aria-hidden="true" name="not"></a><a href="#not" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.not</code></h3>
<p>Si sabe cómo probar algo, <code>.not</code> le permite probar su opuesto. Por ejemplo, este código prueba que el mejor sabor de La Croix no es coco:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'el mejor sabor no es coco'</span>, () =&gt; {
  expect(mejorSaborLaCroix()).not.toBe(<span class="hljs-string">'coco'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="resolves"></a><a href="#resolves" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.resolves</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-2000"></a><a href="#disponible-en-jest-2000" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>20.0.0+</strong></h5>
<p>Utilice<code>resolver</code> para desenvolver el valor de una promesa cumplida para que cualquier otro comparador pueda ser encadenado. Si la promesa es rechazada la afirmación fallará.</p>
<p>Por ejemplo, este código prueba que la promesa se resuelve y que el valor resultante es <code>'lemon'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resuelve a limon'</span>, () =&gt; {
  <span class="hljs-comment">// Es esencial que se agregue un statement de return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
});
</code></pre>
<p>Tenga en cuenta que, dado que todavía esta probando promesas, la prueba sigue siendo asincronica. Por lo tanto, necesitaras <a href="/jest/docs/es-ES/asynchronous.html#promises">tell Jest to wait</a> para devolver la afirmación desenvuelta.</p>
<p>Alternativamente, se puede usar <code>async/await</code> en combinación con <code>.resolves</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resuelve a limon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.not.toBe(<span class="hljs-string">'pulpo'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="rejects"></a><a href="#rejects" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.rejects</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-2000"></a><a href="#disponible-en-jest-2000" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>20.0.0+</strong></h5>
<p>Utilice <code>.rejects</code> para desenvolver la razón de una promesa rechazada para que cualquier otro comparador pueda ser encadenado. Si la promesa de cumple la afirmación fallará.</p>
<p>Por ejemplo, este código prueba que la promesa rechaza con la razón <code>'octopus'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(
    <span class="hljs-string">'octopus'</span>,
  );
});
</code></pre>
<p>Tenga en cuenta que, dado que todavía esta probando promesas, la prueba sigue siendo asincronica. Por lo tanto, necesitaras <a href="/jest/docs/es-ES/asynchronous.html#promises">tell Jest to wait</a> para devolver la afirmación desenvuelta.</p>
<p>Alternativamente, puede utilizar <code>async/await</code> combinado con <code>.rejects</code>.</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobevalue"></a><a href="#tobevalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBe(value)</code></h3>
<p><code>toBe</code> sólo verifica que un valor sea lo que usted espera. Utiliza <code>Object.is</code> para verificar la calidad exacta.</p>
<p>Por ejemplo, el código a continuación valida algunas propiedades del objeto <code>lata</code>:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> lata = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'pomelo'</span>,
  <span class="hljs-attr">onzas</span> : <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'la lata'</span>, () =&gt; {
  test(<span class="hljs-string">'tiene 12 onzas'</span>, () =&gt; {
    expect(lata.onzas).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'tiene un nombre sofisticado'</span>, () =&gt; {
    expect(lata.nombre).toBe(<span class="hljs-string">'pomelo'</span>);
  });
});
</code></pre>
<p>No utilices <code>toBe</code> con números de punto flotante. Por ejemplo, debido al redondeo, en JavaScript <code>0.2 + 0.1</code> no es esctrictamente igual a <code>0.3</code>. Si tiene números de punto flotante, intente <code>.toBeCloseTo</code> en lugar de eso.</p>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalled"></a><a href="#tohavebeencalled" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalled()</code></h3>
<p>También bajo el alias: <code>.toBeCalled()</code></p>
<p>Usa <code>.toHaveBeenCalled</code> para asegurar que una función &quot;mock&quot; fue llamada.</p>
<p>Por ejemplo, digamos que tiene una función <code>drinkAll(drink, flavor)</code> que toma una función <code>drink</code> y la aplica a todas las bebidas disponibles. Quizás quiera comprobar que <code>drink</code> sea llamado por <code>'lemon'</code>, pero no por <code>'octopus'</code>, porque el sabor <code>'octopus'</code> es muy raro ¿Por qué habría siquiera algo con sabor a pulpo? Puedes hacerlo con esta serie de tests:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'beberTodo'</span>, () =&gt; {
  test(<span class="hljs-string">'bebe algo con sabor a limon'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    beberTodo(beber, <span class="hljs-string">'limon'</span>);
    expect(beber).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'no bebe algo con sabor a pulpo'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    drinkAll(beber, <span class="hljs-string">'pulpo'</span>);
    expect(beber).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledtimesnumber"></a><a href="#tohavebeencalledtimesnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledTimes(number)</code></h3>
<p>Utilice <code>.toHaveBeenCalledTimes</code> para asegurar que una función de simulación fue llamada un número de veces exacto.</p>
<p>Por ejemplo, digamos que tiene una función <code>drinkEach(drink, Array&lt;flavor&gt;)</code> que tome una función <code>drink</code> y la aplique para un arreglo de bebidas pasadas. Es probable que pida controlar que la función de bebida se hubiera llamado el número exacto de veces. Puede hacer eso con este suite de prueba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beberCada bebe cada bebida'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beber = jest.fn();
  beberCada(beber, [<span class="hljs-string">'limon'</span>, <span class="hljs-string">'pulpo'</span>]);
  expect(beber).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledwitharg1-arg2-"></a><a href="#tohavebeencalledwitharg1-arg2-" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.toBeCalledWith()</code></p>
<p>Utilice <code>.toHaveBeenCalledWith</code> para asegurarse de que una función de simulación fue llamada con argumentos específicos.</p>
<p>Por ejemplo, digamos que puede registrar una bebida con función de <code>register</code>, y <code>applyToAll(f)</code> debería aplicar la función <code>f</code> a todas las bebidas registradas. Para asegurarte que funciona, puedes escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'registro aplicado correctamente a La Croix naranja'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'naranja'</span>);
  registrar(bebida);
  <span class="hljs-keyword">const</span> f = jest.fn();
  aplicarATodo(f);
  expect(f).toHaveBeenCalledWith(bebida);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeenlastcalledwitharg1-arg2-"></a><a href="#tohavebeenlastcalledwitharg1-arg2-" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Si tiene una función de simulación, puede utilizar <code>.toHaveBeenLastCalledWith</code> para probar con qué argumentos fue llamado anteriormente. Por ejemplo, digamos que tiene una función <code>applyToAllFlavors(f)</code> que aplica <code>f</code> a un montón de sabores, y quiere asegurarse de que cuando lo llame, el último sabor que opere sea <code>'mango'</code>. Puedes escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'aplicarATodosLosSabores deja el mango para el final'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = jest.fn();
  aplicarATodosLosSabores(bebida);
  expect(bebida).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeclosetonumero-numerodigitos"></a><a href="#tobeclosetonumero-numerodigitos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeCloseTo(número, númeroDigitos)</code></h3>
<p>Es una mala idea usar la igualdad exacta con los números de coma flotante Redondear significa que las cosas intuitivas fallan. Por ejemplo, esta prueba falla:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Falla!</span>
});
</code></pre>
<p>Falla porque en JavaScript, <code>0.2 + 0.1</code> es en realidad <code>0.30000000000000004</code>. Lástima.</p>
<p>En su lugar, usa <code>.toBeCloseTo</code>. Utilice <code>numDigits</code> para controlar cuántos digitos luego del punto decimal debe verificar. Por ejemplo, si quiere estar seguro de que <code>0.2 + 0.1</code> sea igual a <code>0.3</code> con una precisión de 5 digitos decimales, puede utilizar esta prueba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p><code>numDigits</code> es 2, por defecto, lo cual ha demostrado ser una buena configuración en la mayoría de los casos.</p>
<h3><a class="anchor" aria-hidden="true" name="tobedefined"></a><a href="#tobedefined" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeDefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable no sea undefined. Por ejemplo, si sólo quiere verificar que una función <code>fetchNewFlavorIdea()</code> arroje <em>algo</em>, puede escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'hay una nueva idea de sabor'</span>, () =&gt; {
  expect(conseguirNuevaIdeaSabor()).toBeDefined();
});
</code></pre>
<p>Podría escribir <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, pero es más práctico evitar referise a <code>undefined</code> directamente en su código.</p>
<h3><a class="anchor" aria-hidden="true" name="tobefalsy"></a><a href="#tobefalsy" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeFalsy()</code></h3>
<p>Utilice <code>.toBeFalsy</code> cuando no le importe que valor es, sólo quiere asegurarse de que el valor sea falso en un contexto booleano. Por ejemplo, digamos que tiene algún código de aplicación que se ve así:</p>
<pre><code class="hljs css js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (!conseguirErrores()) {
  beberMasLaCroix();
}
</code></pre>
<p>Puede que no le importe lo que arroje <code>getErrors</code>, específicamente - podría arrojar <code>false</code>, <code>null</code>, o ``, y su código aún funcionaría. Así que si desea probar que no hay errores luego de beber algo de La Croix, podría escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beber LaCroix no provoca errores'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(conseguirErrores()).toBeFalsy();
});
</code></pre>
<p>En JavaScript, existen seis valores falsos: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, y <code>NaN</code>. Todo lo demás es verdadero.</p>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthannumero"></a><a href="#tobegreaterthannumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThan(número)</code></h3>
<p>Para comparar números de punto flotante, puede utilizar <code>toBeGreaterThan</code>. Por ejemplo, si quiere probar que <code>ouncesPerCan()</code> arroja un valor de más de 10 onzas, escriba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es mayor a 10'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthanorequalnumero"></a><a href="#tobegreaterthanorequalnumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThanOrEqual(número)</code></h3>
<p>Para comparar números de punto flotante, puede utilizar <code>toBeGreaterThanOrEqual</code>. Por ejemplo, si quiere probar que <code>ouncesPerCan()</code> arroja un valor de al menos 12 onzas, escriba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es por lo menos 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthannumero"></a><a href="#tobelessthannumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThan(número)</code></h3>
<p>Para comparar números de punto flotante, puede utilizar <code>toBeLessThan</code>. Por ejemplo, si quiere probar que <code>ouncesPerCan()</code> arroja un valor de al menos 20 onzas, escriba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es menor a 20'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthanorequalnumero"></a><a href="#tobelessthanorequalnumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThanOrEqual(número)</code></h3>
<p>Para comparar números de punto flotante, puede utilizar <code>toBeLessThanOrEqual</code>. Por ejemplo, si quiere probar que <code>ouncesPerCan()</code> arroja un valor de máximo 12 onzas, escriba:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es a lo mucho 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeinstanceofclass"></a><a href="#tobeinstanceofclass" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeInstanceOf(Class)</code></h3>
<p>Utilice <code>.toBeInstanceOf(Class)</code> para verificar que un objeto es una instancia de una clase. Este comparador utiliza <code>instanceof</code> por debajo.</p>
<pre><code class="hljs css js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// avienta error</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobenull"></a><a href="#tobenull" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNull()</code></h3>
<p><code>.toBeNull()</code> is the same as <code>.toBe(null)</code> but the error messages are a bit nicer. So use <code>.toBeNull()</code> when you want to check that something is null.</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop regresa null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobetruthy"></a><a href="#tobetruthy" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeTruthy()</code></h3>
<p>Use <code>.toBeTruthy</code> when you don't care what a value is, you just want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (infoSed()) {
  beberMasLaCroix();
}
</code></pre>
<p>You may not care what <code>thirstInfo</code> returns, specifically - it might return <code>true</code> or a complex object, and your code would still work. So if you just want to test that <code>thirstInfo</code> will be truthy after drinking some La Croix, you could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beber La Croix lleva a conseguir info de sed'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(infoSed()).toBeTruthy();
});
</code></pre>
<p>En JavaScript, existen seis valores falsos: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, y <code>NaN</code>. Todo lo demás es verdadero.</p>
<h3><a class="anchor" aria-hidden="true" name="tobeundefined"></a><a href="#tobeundefined" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeUndefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable es undefined. For example, if you want to check that a function <code>bestDrinkForFlavor(flavor)</code> returns <code>undefined</code> for the <code>'octopus'</code> flavor, because there is no good octopus-flavored drink:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'la mejor bebida con sabor a pulpo es undefined'</span>, () =&gt; {
  expect(mejorBebidaPorSabor(<span class="hljs-string">'pulpo'</span>)).toBeUndefined();
});
</code></pre>
<p>You could write <code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>, but it's better practice to avoid referring to <code>undefined</code> directly in your code.</p>
<h3><a class="anchor" aria-hidden="true" name="tocontainitem"></a><a href="#tocontainitem" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContain(item)</code></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'la lista de sabores contiene lima'</span>, () =&gt; {
  expect(conseguirTodosSabores()).toContain(<span class="hljs-string">'lima'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tocontainequalitem"></a><a href="#tocontainequalitem" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContainEqual(item)</code></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa y no es agría'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> miBebida = {<span class="hljs-attr">deliciosa</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">agria</span>: <span class="hljs-literal">false</span>};
    expect(misBebidas()).toContainEqual(miBebida);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="toequalvalue"></a><a href="#toequalvalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toEqual(value)</code></h3>
<p>Utilice <code>.toEqual</code> cuando se desee verificar que dos objetos tienen el mismo valor. This matcher recursively checks the equality of all fields, rather than checking for object identity—this is also known as &quot;deep equal&quot;. For example, <code>toEqual</code> and <code>toBe</code> behave differently in this test suite, so all the tests pass:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> lata1 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> lata2 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'las latas de La Croix en mi escritorio'</span>, () =&gt; {
  test(<span class="hljs-string">'tienen las mismas propiedades'</span>, () =&gt; {
    expect(lata1).toEqual(lata2);
  });
  test(<span class="hljs-string">'no son la misma lata'</span>, () =&gt; {
    expect(lata1).not.toBe(lata2);
  });
});
</code></pre>
<blockquote>
<p>Nota: <code>.toEqual</code> no realizara una verificación de <em>igualdad profunda</em> para dos errores. Only the <code>message</code> property of an Error is considered for equality. It is recommended to use the <code>.toThrow</code> matcher for testing against errors.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tohavelengthnumber"></a><a href="#tohavelengthnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLength(number)</code></h3>
<p>Use <code>.toHaveLength</code> to check that an object has a <code>.length</code> property and it is set to a certain numeric value.</p>
<p>Es especialmente útil para verificar el tamaño de cadenas o arreglos.</p>
<pre><code class="hljs css js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchregexporstring"></a><a href="#tomatchregexporstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatch(regexpOrString)</code></h3>
<p>Utilice <code>.toMatch</code> para verificar que la cadena coincida con una expresión regular (Regex).</p>
<p>For example, you might not know what exactly <code>essayOnTheBestFlavor()</code> returns, but you know it's a really long string, and the substring <code>grapefruit</code> should be in there somewhere. Podemos probarlo con:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'un ensayo sobre el mejor sabor'</span>, () =&gt; {
  test(<span class="hljs-string">'menciona toronja'</span>, () =&gt; {
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-regexp">/toronja/</span>);
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'toronja'</span>));
  });
});
</code></pre>
<p>Este método acepta también una cadena, con la que va a intentar coincidir:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'las toronjas son saludables'</span>, () =&gt; {
  test(<span class="hljs-string">'las toronjas son frutas'</span>, () =&gt; {
    expect(<span class="hljs-string">'toronjas'</span>).toMatch(<span class="hljs-string">'fruta'</span>);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchobjectobject"></a><a href="#tomatchobjectobject" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchObject(object)</code></h3>
<p>Use <code>.toMatchObject</code> to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are <strong>not</strong> in the expected object.</p>
<p>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the <code>toMatchObject</code> sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to <code>arrayContaining</code>, which allows for extra elements in the received array.</p>
<p>Se puede hacer match de propiedades a través de sus valores o con matchers.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> casaEnVenta = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">habitaciones</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">colorPared</span>: <span class="hljs-string">'blanco'</span>,
  },
};
<span class="hljs-keyword">const</span> casaDeseada = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">colorPared</span>: expect.stringMatching(<span class="hljs-regexp">/blanco|amarillo/</span>),
  },
};

test(<span class="hljs-string">'la casa tiene las propiedades deseadas'</span>, () =&gt; {
  expect(casaEnVenta).toMatchObject(casaDeseada);
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that</span>
  <span class="hljs-comment">// are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span>}]).toMatchObject([
      {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>},
      {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>},
    ]);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavepropertypathllave-valor"></a><a href="#tohavepropertypathllave-valor" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveProperty(pathLlave, valor)</code></h3>
<p>Use <code>.toHaveProperty</code> to check if property at provided reference <code>keyPath</code> exists for an object. For checking deeply nested properties in an object you may use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> or an array containing the keyPath for deep references.</p>
<p>Optionally, you can provide a <code>value</code> to check if it's equal to the value present at <code>keyPath</code> on the target object. This matcher uses 'deep equality' (like <code>toEqual()</code>) and recursively checks the equality of all fields.</p>
<p>El siguiente ejemplo contiene un objeto <code>casaEnVenta</code> con propiedades anidadas. We are using <code>toHaveProperty</code> to check for the existence and values of various properties in the object.</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);

  <span class="hljs-comment">// Deep referencing using an array containing the keyPath</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'area'</span>], <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(
    [<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>],
    [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
  );
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>, <span class="hljs-number">0</span>], <span class="hljs-string">'oven'</span>);

  expect(houseForSale).not.toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'open'</span>]);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchsnapshotoptionalstring"></a><a href="#tomatchsnapshotoptionalstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchSnapshot(optionalString)</code></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/es-ES/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>You can also specify an optional snapshot name. Otherwise, the name is inferred from the test.</p>
<p><em>Nota: Si bien la prueba de instantáneas se usa con mayor frecuencia con los componentes de React, cualquier valor serializable se puede utilizar como una instantánea.</em></p>
<h3><a class="anchor" aria-hidden="true" name="tothrowerror"></a><a href="#tothrowerror" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrow(error)</code></h3>
<p>También bajo el alias: <code>.toThrowError(error)</code></p>
<p>Utilice <code>.toThrow</code> en una prueba para verificar que una función arroja un error cuando se llama. For example, if we want to test that <code>drinkFlavor('octopus')</code> throws, because octopus flavor is too disgusting to drink, we could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }).toThrow();
});
</code></pre>
<p>If you want to test that a specific error gets thrown, you can provide an argument to <code>toThrow</code>. The argument can be a string for the error message, a class for the error, or a regex that should match the error. For example, let's say that <code>drinkFlavor</code> is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>Podríamos probar que este error lanza una excepción de varias formas:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  <span class="hljs-comment">// Probar el mensaje de error</span>
  expect(beberPulpo).toThrowError(<span class="hljs-string">'guac! sabor a pulpo'</span>);

  <span class="hljs-comment">// Probar que el mensaje de error contiene "guac" en algún lugar del mensaje</span>
  expect(beberPulpo).toThrowError(<span class="hljs-regexp">/guac/</span>);

  <span class="hljs-comment">// Probar que arroja un error ErrorSaborRepugnante</span>
  expect(beberPulpo).toThrowError(ErrorSaborRepugnante);
});
</code></pre>
<blockquote>
<p>Nota: debe envolver el código en una función, al lo contrario el error no se detectará y la afirmación fallará.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tothrowerrormatchingsnapshot"></a><a href="#tothrowerrormatchingsnapshot" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingSnapshot()</code></h3>
<p>Use <code>.toThrowErrorMatchingSnapshot</code> to test that a function throws an error matching the most recent snapshot when it is called. For example, let's say you have a <code>drinkFlavor</code> function that throws whenever the flavor is <code>'octopus'</code>, and is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>El test para esta función se verá así:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  expect(beberPulpo).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Y generará el siguiente snapshot:</p>
<pre><code class="hljs css js">exports[<span class="hljs-string">`drinking flavors throws on octopus 1`</span>] = <span class="hljs-string">`"yuck, octopus flavor"`</span>;
</code></pre>
<p>Revisa <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a> para mas información sobre la prueba de la foto instantánea.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/es-ES/getting-started.html">Getting Started</a><a href="/jest/docs/es-ES/snapshot-testing.html">Guides</a><a href="/jest/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/es-ES/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script></body></html>