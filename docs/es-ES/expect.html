<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Cuando estás escribiendo tests, a menudo necesitas comprobar que los valores cumplen ciertas condiciones. `expect` te da acceso a un número de marcadores que te permiten validar diferentes cosas."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/es-ES/getting-started.html" target="_self">Documentación</a></li><li><a href="/jest/docs/es-ES/api.html" target="_self">API</a></li><li><a href="/jest/es-ES/help.html" target="_self">Ayuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/es-ES/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>Cuando estás escribiendo tests, a menudo necesitas comprobar que los valores cumplen ciertas condiciones. <code>expect</code> te da acceso a un número de marcadores que te permiten validar diferentes cosas.</p>
<h2><a class="anchor" name="metodos"></a>Métodos <a class="hash-link" href="#metodos">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referencia"></a>Referencia <a class="hash-link" href="#referencia">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p>La función <code>expect</code> se utiliza cada vez que desea testear un valor. Rara vez se utiliza <code>expect</code> por sí mismo. En su lugar, utilizarás <code>expect</code> junto a una función de &quot;comparación&quot; para afirmar algo sobre un valor.</p>
<p>Es más fácil entenderlo con este ejemplo. Digamos que tenemos un método <code>mejorSabor()</code> que se supone que devuelve el texto <code>'grapefruit'</code>. Así es cómo sería el test:</p>
<pre><code class="language-js">test(<span class="hljs-string">'el mejor sabor es de melocotón'</span>, () =&gt; {
  expect(mejorSabor()).toBe(<span class="hljs-string">'melocotón'</span>);
});
</code></pre>
<p>En este caso, <code>toBe</code> es la función de comparación. Hay una gran cantidad de funciones matcher diferentes, documentadas a continuación, para ayudarte a probar cosas diferentes.</p>
<p>El argumento <code>expect</code> debe ser el valor que produce tu código, y cualquier argumento de comparación debe ser el valor correcto. Si los mezclas, tus test problablemente seguiran funcionando, pero los mensajes de error seran confusos.</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p>Puedes utilizar <code>expect.extend</code> para añadir tus propios comparadores a Jest. Por ejemplo, digamos que estás probando una librería de operaciones numéricas y con frecuencia estás afirmando que los números son divisibles por otros números. Podrías abstraer a un comparador de <code>divisiblePor</code>:</p>
<pre><code class="language-js">expect.extend({
  divisiblePor(recibido, argumento) {
    <span class="hljs-keyword">const</span> pass = (recibido % argumento == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`se esperaba <span class="hljs-subst">${recibido}</span> no es divisible por <span class="hljs-subst">${argumento}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`se esperaba <span class="hljs-subst">${recibido}</span> ser divisible por <span class="hljs-subst">${argumento}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'números par y impar'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).divisiblePor(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.divisiblePor(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Los comparadores deben devolver un objeto con dos parámetros. <code>pass</code> indica si hubo un acierto o no, y <code>message</code> proporciona una función sin argumentos que devuelve un mensaje de error en caso de fallo. Así, cuando <code>pass</code> es falso, <code>message</code> debe devolver el mensaje de error para cuando <code>expect(x).tuComparador()</code>. Y cuando <code>pass</code> es 'true', <code>message</code> debe devolver el mensaje de error para cuando <code>expect(x).not.tuComparador()</code>.</p>
<p>Éstas funciones auxiliares se pueden encontrar dentro de <code>this</code> como comparador personalizado:</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>Un boleano te permite conocer si un comparador fue llamado con el modificador de negación <code>.not</code>, permitiendo negar la afirmación.</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>Esta es una función de igualdad profunda que regresará <code>true</code> si dos objetos tienen los mismos valores (recursivamente).</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p>Hay un número de herramientas de utilidad reveladas en <code>this.utils</code> que consisten en las funciones de <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Las más útiles son <code>matcherHint</code>, <code>printExpected</code> y <code>printReceived</code> para dar formato mas agradable a los mensajes de error. Por ejemplo, echa un vistazo en la implementación para el comparador <code>toBe</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Esto mostrará algo así:</p>
<pre><code>  expect(recibido).toBe(esperado)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>Cuando una afirmación falla, el mensaje de error debería dar las señales necesarias para que el usuario pueda resolver sus problemas rápidamente. Deberías crear mensajes de errores precisos para que los usuarios de tus afirmaciones personalizadas se sientan cómodos usándolas.</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> aprobará cualquier cosa excepto <code>null</code> o <code>undefined</code>. Pedes usarlo dentro de <code>toEqual</code> o <code>toBeCalledWith</code> en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un argumento que no sea null:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> aprueba cualquier cosa que sea creada con el constructor recibido. Pedes usarlo dentro de <code>toEqual</code> o <code>toBeCalledWith</code> en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un número:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> aprueba que la matriz recibida contiene todos los elementos de la matriz esperada. Eso significa que la matriz esperada es un <strong>subconjunto</strong> de la matriz recibida. Por tanto, aprueba una matriz recibida que contenga elementos que <strong>no</strong> estén en la matriz esperada.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> verifica que un cierto número de afirmaciones han sido realizadas durante un test. Esto es útil a la hora de probar código asíncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas.</p>
<p>Por ejemplo, supongamos que tenemos una función <code>doAsync</code> que recibe dos devoluciones de llamada <code>callback1</code> y <code>callback2</code>, asincrónicamente se llamará a ambas en un orden desconocido. Podemos comprobarlo con:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync llama a ambos callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>La llamada de <code>expect.assertions(2)</code> asegura que ambas devoluciones de llamada son efectivamente ejecutadas.</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code> verifica que al menos una verificación es llamada durante un test. Esto es útil a la hora de probar código asíncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas.</p>
<p>Por ejemplo, digamos que tenemos unas pocas funciones y todas tratan con un estado. <code>prepareState</code> llama a una devolución de llamada con un objeto de estado, <code>validateState</code> se ejecuta en este objeto de estado, y <code>waitOnState</code> devuelve una promesa que espera hasta que las devoluciones de llamada de <code>prepareState</code> completen. Podemos comprobarlo con:</p>
<pre><code class="language-js">test(<span class="hljs-string">'prepareState prepara un estado valido'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(estado)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>La llamada de <code>expect.hasAssertions()</code> asegura que ambas devoluciones de llamada de <code>prepareState</code> son efectivamente ejecutadas.</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> compara recursivamente con cualquier objeto recibido que cumpla con las propiedades esperadas. Es decir, el objeto esperado es un <strong>subconjunto</strong> del objeto recibido. De tal manera que, hace match con un objeto que contiene propiedades que <strong>no</strong> se encuentran en el objeto esperado.</p>
<p>En lugar de verificar los valores de propiedades en el objeto esperado, se pueden ocupar matchers, como <code>expect.anything()</code>, entre otros.</p>
<p>Por ejemplo, si se espera que la función <code>onPress</code> sea llamada con el objeto <code>Event</code>, y solo se necesita verificar que el evento tiene las propiedades <code>event.x</code> y <code>event.y</code>. Puedes hacer esto con:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress es llamado con argumentos correctos'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="disponible-en-jest-1900"></a>disponible en Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponible-en-jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code> coincide con cualquier cadena de texto recibida que contenga la cadena de texto exacta.</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(regexp)</code> coincide con cualquier cadena recibida que coincida con la expresión regular esperada.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para que coincida con un elemento en <code>arrayContaining</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<p>Este ejemplo también muestra cómo se pueden anidar múltiples marcadores de comparación asimétricas, con <code>expect.stringMatching</code> dentro de <code>expect.arrayContaining</code>.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching en arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> esperado = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'hace match incluso si se reciben elementos adicionales'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(esperado));
  });
  it(<span class="hljs-string">'no hace match si lo recibido no contiene los elementos esperados'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(esperado));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p>Puedes llamar a <code>expect.addSnapshotSerializer</code> para agregar un módulo que formatee estructuras de datos específicas de la aplicación.</p>
<p>Para un archivo de test individual, un módulo añadido precede a los módulos de <code>snapshotSerializers</code> en la configuración, que preceden los serializadores de instantánea predeterminados para tipos de JavaScript integrados y elementos de React. El último módulo añadido, es el primero módulo testeado.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test</span>
</code></pre>
<p>Si añades un serializador de instantánea en los archivos de test individuales en vez de a agregarlo a la configuración de <code>snapshotSerializers</code>:</p>
<ul>
<li>Haces la dependencia explícita en lugar de implícita.</li>
<li>Evitas límites de la configuración que podría causarte expulsar desde <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/es-ES/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>Si sabes cómo testear algo, <code>.no</code> te permite comprobar su opuesto. Por ejemplo, este código testea que el mejor sabor de La Croix no es coco:</p>
<pre><code class="language-js">test(<span class="hljs-string">'el mejor sabor no es coco'</span>, () =&gt; {
  expect(mejorSaborLaCroix()).not.toBe(<span class="hljs-string">'coco'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="disponible-en-jest-2000"></a>disponible en Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponible-en-jest-2000">#</a></h5>
<p>Utiliza <code>resolves</code> para desenvolver el valor de una promesa cumplida, para que así cualquier otro marcados pueda ser encadenado. Si la promesa se rechaza la afirmación falla.</p>
<p>Por ejemplo, este código testea que la promesa resuelve y que el valor resultando es <code>'limon'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resuelve a limon'</span>, () =&gt; {
  <span class="hljs-comment">// Es esencial que se agregue un statement de return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
});
</code></pre>
<p>Alternativamente, se puede usar <code>async/await</code> en combinación con <code>.resolves</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resuelve a limon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.not.toBe(<span class="hljs-string">'pulpo'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="disponible-en-jest-2000"></a>disponible en Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponible-en-jest-2000">#</a></h5>
<p>Usa <code>.rejects</code> para desenvolver el valor de una promesa cumplida, para que así cualquier otro marcados pueda ser encadenado. Si la promesa es rechazada la afirmación falla.</p>
<p>Por ejemplo, este código de test que la promesa rechaza con una razón:</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rechaza para ser un error'</span>, () =&gt; {
  <span class="hljs-comment">// Es esencial que se agregue un statement de return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'pulpo'</span>)).rejects.toBeDefined();
});
</code></pre>
<p>Alternativamente, se puede usar <code>async/await</code> en combinación con <code>.rejects</code>. Además, este código comprueba que la razón devuelta incluye 'octopus':</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rechaza para ser un error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> bebidaPulpo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'puaf, sabor a pulpo'</span>);
  });

  <span class="hljs-keyword">await</span> expect(bebidaPulpo).rejects.toMatch(<span class="hljs-string">'pulpo'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> solo comprueba que un valor es lo que se espera. Utiliza <code>===</code> para la comprobarla igualdad estricta.</p>
<p>Por ejemplo, el código a continuación valida algunas propiedades del objeto <code>lata</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> lata = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'pomelo'</span>,
  <span class="hljs-attr">onzas</span> : <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'la lata'</span>, () =&gt; {
  test(<span class="hljs-string">'tiene 12 onzas'</span>, () =&gt; {
    expect(lata.onzas).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'tiene un nombre sofisticado'</span>, () =&gt; {
    expect(lata.nombre).toBe(<span class="hljs-string">'pomelo'</span>);
  });
});
</code></pre>
<p>No utilices <code>toBe</code> con números de punto flotante. Por ejemplo, debido al redondeo, en JavaScript <code>0,2 + 0,1</code> no es estrictamente igual a <code>0,3</code>. Si tienes números de punto flotante, prueba <code>.toBeCloseTo</code> en su lugar.</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>También bajo el alias: <code>.toBeCalled()</code></p>
<p>Usa <code>.toHaveBeenCalled</code> para asegurar que una función &quot;mock&quot; fue llamada.</p>
<p>Por ejemplo, digamos que tienes una función <code>beberTodo(beber, sabor)</code> que tiene una función <code>beber</code> y la aplica a todas las bebidas disponibles. Podrías querer comprobar que este <code>beber</code> es llamado para <code>'limon'</code>, pero no para <code>'pulpo'</code>, porque el sabor de <code>'pulpo'</code> es realmente extraño y, ¿por qué iba a tener algo sabor a pulpo? Puedes hacerlo con esta serie de tests:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'beberTodo'</span>, () =&gt; {
  test(<span class="hljs-string">'bebe algo con sabor a limon'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    beberTodo(beber, <span class="hljs-string">'limon'</span>);
    expect(beber).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'no bebe algo con sabor a pulpo'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    drinkAll(beber, <span class="hljs-string">'pulpo'</span>);
    expect(beber).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>Usa <code>.toHaveBeenCalledTimes</code> para asegurar que una función &quot;mock&quot; se llamo un número de veces exacto.</p>
<p>Por ejemplo, digamos que tienes una función <code>beberCada(beber, Array&lt;sabor&gt;)</code> que toma una función <code>beber</code> y la aplica a un arreglo de bebidas. Puede que quieras comprobar que la función beber se llamó un numero exacto de veces. Puedes hacerlo con esta serie de tests:</p>
<pre><code class="language-js">test(<span class="hljs-string">'beberCada bebe cada bebida'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beber = jest.fn();
  beberCada(beber, [<span class="hljs-string">'limon'</span>, <span class="hljs-string">'pulpo'</span>]);
  expect(beber).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>También bajo el alias: <code>.toBeCalledWith()</code></p>
<p>Usa <code>.toHaveBeenCalledWith</code> para asegurar que una función mock haya sido llamada con argumentos específicos.</p>
<p>Por ejemplo, digamos que tienes una bebida con una función <code>registrar</code>, y <code>aplicarATodo(f)</code> que aplica la función <code>f</code> a todas las bebidas registradas. Para asegurarte que funciona, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registro aplicado correctamente a La Croix naranja'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'naranja'</span>);
  registrar(bebida);
  <span class="hljs-keyword">const</span> f = jest.fn();
  aplicarATodo(f);
  expect(f).toHaveBeenCalledWith(bebida);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>También bajo el alias: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Si tienes una función mock, puedes usar <code>.toHaveBeenLastCalledWith</code> para ver los argumentos con los que fue llamada la ultima vez. Por ejemplo digamos que tienes una función <code>aplicarATodosLosSabores(f)</code> que aplica la función <code>f</code> a diversos sabores, y quieres asegurarte que la ultima vez que se llama a esta función el último sabor al que se le aplica la función es <code>'mango'</code>. Puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'aplicarATodosLosSabores deja el mango para el final'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = jest.fn();
  aplicarATodosLosSabores(bebida);
  expect(bebida).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumero-numerodigitos"></a><code>.toBeCloseTo(número, númeroDigitos)</code> <a class="hash-link" href="#tobeclosetonumero-numerodigitos">#</a></h3>
<p>Usar la igualdad exacta con números de punto flotante es una mala idea. Redondear hace que cosas que parecen intuitivas puedan fallar. Por ejemplo, esta prueba falla:</p>
<pre><code class="language-js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Falla!</span>
});
</code></pre>
<p>Esto falla porque en Javascript, <code>0.2 + 0.1</code> es en realidad <code>0.30000000000000004</code>. Lástima.</p>
<p>En su lugar, usa <code>.toBeCloseTo</code>. Utiliza <code>numDigits</code> para controlar cuántos dígitos después del punto decimal se deben verificar. Por ejemplo, si quieres estar seguro que <code>0.2 + 0.1</code> es igual a <code>0.3</code> con una precisión de 5 dígitos decimales, puedes ocupar esta prueba:</p>
<pre><code class="language-js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>El valor por defecto para <code>númeroDigitos</code> es 2, el cual ha demostrado ser un buen valor por defecto para la mayoría de los casos.</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable no sea undefined. Por ejemplo, si deseas verificar que la función <code>conseguirNuevaIdeaSabor()</code> regresa <em>algo</em>, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'hay una nueva idea de sabor'</span>, () =&gt; {
  expect(conseguirNuevaIdeaSabor()).toBeDefined();
});
</code></pre>
<p>Puedes escribir <code>expect(conseguirNuevaIdeaSabor()).not.toBe(undefined)</code>, pero es buena practica omitir el uso de <code>undefined</code> directamente en el código.</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>Usa <code>.toBeFalsy</code> cuando no te importa el valor y solo te interesa saber si el valor es falso en un contexto booleano. Por ejemplo, digamos que algún fragmento de una aplicación se ve algo así:</p>
<pre><code class="language-js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (!conseguirErrores()) {
  beberMasLaCroix();
}
</code></pre>
<p>Puede que no te importe el valor que <code>conseguirErrores</code> regrese, específicamente - podría regresar <code>false</code>, <code>null</code>, o ``, y el código funcionaría correctamente. Si quieres probar que no hay errores después de tomar algo de La Croix, podrías escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'beber LaCroix no provoca errores'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(conseguirErrores()).toBeFalsy();
});
</code></pre>
<p>En JavaScript, hay seis valores falsos en contexto booleano, o &quot;falsy&quot;: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, y <code>NaN</code>. Cualquier otro valor es verdadero en contexto booleano, o &quot;truthy&quot;.</p>
<h3><a class="anchor" name="tobegreaterthannumero"></a><code>.toBeGreaterThan(número)</code> <a class="hash-link" href="#tobegreaterthannumero">#</a></h3>
<p>Para comparar números de punto flotante, puedes usar <code>toBeGreaterThan</code>. Por ejemplo, si deseas probar que <code>onzasPorLata()</code> regresa un valor de más de 10 onzas, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onzas por lata es mayor a 10'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumero"></a><code>.toBeGreaterThanOrEqual(número)</code> <a class="hash-link" href="#tobegreaterthanorequalnumero">#</a></h3>
<p>Para comparar números de punto flotante, puedes usar <code>toBeGreaterThanOrEqual</code>. Por ejemplo, si deseas probar que <code>onzasPorLata()</code> regresa un valor de por lo menos 12 onzas, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onzas por lata es por lo menos 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumero"></a><code>.toBeLessThan(número)</code> <a class="hash-link" href="#tobelessthannumero">#</a></h3>
<p>Para comparar números de punto flotante, puedes usar <code>toBeLessThan</code>. Por ejemplo, si deseas probar que <code>onzasPorLata()</code> regresa un valor de menor a 20 onzas, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onzas por lata es menor a 20'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumero"></a><code>.toBeLessThanOrEqual(número)</code> <a class="hash-link" href="#tobelessthanorequalnumero">#</a></h3>
<p>Para comparar números de punto flotante, puedes usar <code>toBeLessThanOrEqual</code>. Por ejemplo, si deseas probar que <code>onzasPorLata()</code> regresa un valor de a lo mucho 12 onzas, puedes escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onzas por lata es a lo mucho 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>Utiliza <code>.toBeInstanceOf(Class)</code> para verificar que un objeto es instancia de cierta clase. Esta comparación se realiza de manera interna ocupando <code>instanceof</code>.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// avienta error</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> es idéntico a <code>.toBe(null)</code> pero con mensajes de error más claros. Por tanto, es preferible usar <code>.toBeNull()</code> para verificar si algo es nulo.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop regresa null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>Usa <code>.toBeTruthy</code> cuando no te importa el valor y solo te interesa saber si el valor es verdadero en un contexto booleano. Por ejemplo, digamos que algún fragmento de una aplicación se ve algo así:</p>
<pre><code class="language-js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (infoSed()) {
  beberMasLaCroix();
}
</code></pre>
<p>Puede que no te importe el valor que <code>infoSed</code> regrese, específicamente - podría regresar <code>true</code>o un objeto complejo, y el código funcionaría correctamente. Así que si solo te interesa probar que <code>infoSed</code> sea verdadero en un contexto booleano, o &quot;truthy&quot; después de beber un poco de La Croix, podrías escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'beber La Croix lleva a conseguir info de sed'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(infoSed()).toBeTruthy();
});
</code></pre>
<p>En JavaScript, hay seis valores falsos en contexto booleano, o &quot;falsy&quot;: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, y <code>NaN</code>. Cualquier otro valor es verdadero en contexto booleano, o &quot;truthy&quot;.</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable es undefined. Por ejemplo, si quieres verificar que la función <code>mejorBebidaPorSabor(sabor)</code> regresa <code>undefined</code> para el sabor <code>'pulpo'</code>, porque no existe ninguna bebida con sabor a pulpo que sepa bien:</p>
<pre><code class="language-js">test(<span class="hljs-string">'la mejor bebida con sabor a pulpo es undefined'</span>, () =&gt; {
  expect(mejorBebidaPorSabor(<span class="hljs-string">'pulpo'</span>)).toBeUndefined();
});
</code></pre>
<p>Podría escribir <code>expect(mejorBebidaPorSabor('pulpo')).toBe(undefined)</code>, pero es buena practica omitir el uso de <code>undefined</code> directamente en el código.</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="language-js">test(<span class="hljs-string">'la lista de sabores contiene lima'</span>, () =&gt; {
  expect(conseguirTodosSabores()).toContain(<span class="hljs-string">'lima'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa y no es agría'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> miBebida = {<span class="hljs-attr">deliciosa</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">agria</span>: <span class="hljs-literal">false</span>};
    expect(misBebidas()).toContainEqual(miBebida);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>Utilice <code>.toEqual</code> cuando se desee verificar que dos objetos tienen el mismo valor. Este método verifica la igualdad de todos los campos, en lugar de verificar la identidad del objeto - a esto se le conoce también como &quot;igualdad profunda&quot;. Por ejemplo, <code>toEqual</code> y <code>toBe</code> se comportan diferentemente en esta serie de tests, así que todos los tests pasan:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> lata1 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> lata2 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'las latas de La Croix en mi escritorio'</span>, () =&gt; {
  test(<span class="hljs-string">'tienen las mismas propiedades'</span>, () =&gt; {
    expect(lata1).toEqual(lata2);
  });
  test(<span class="hljs-string">'no son la misma lata'</span>, () =&gt; {
    expect(lata1).not.toBe(lata2);
  });
});
</code></pre>
<blockquote>
<p>Nota: <code>.toEqual</code> no realizara una verificación de <em>igualdad profunda</em> para dos errores. Sólo la propiedad <code>message</code> de un error se verifica para comparar igualdad. Se recomienda utilizar el método <code>.toThrow</code> para probar errores.</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>Utilice <code>.toHaveLength</code> para verificar que un objeto tenga longitud de <code>.length</code> y tenga cierto valor numérico.</p>
<p>Es especialmente útil para verificar el tamaño de cadenas o arreglos.</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>Utilice <code>.toMatch</code> para verificar que la cadena coincida con una expresión regular (Regex).</p>
<p>Por ejemplo, puede que no sepas el valor exacto que <code>ensayoSobreElMejorSabor()</code> regresa, pero sabes que es una cadena muy larga, y que la cadena <code>toronja</code> es parte del contenido. Podemos probarlo con:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'un ensayo sobre el mejor sabor'</span>, () =&gt; {
  test(<span class="hljs-string">'menciona toronja'</span>, () =&gt; {
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-regexp">/toronja/</span>);
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'toronja'</span>));
  });
});
</code></pre>
<p>Este método acepta también una cadena, con la que va a intentar coincidir:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'las toronjas son saludables'</span>, () =&gt; {
  test(<span class="hljs-string">'las toronjas son frutas'</span>, () =&gt; {
    expect(<span class="hljs-string">'toronjas'</span>).toMatch(<span class="hljs-string">'fruta'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>Usa <code>.toMatchObject</code> para comprobar que un objeto de JavaScript coincide con un subconjunto de las propiedades de un objeto. Hará match de objetos recibidos cuyas propiedades <strong>no</strong> están en el objeto esperado.</p>
<p>También se puede pasar un arreglo de objetos, en cuyo caso el método regresara true solo si cada objeto en el arreglo hace match (como descrito en <code>toMatchObject</code> anteriormente) con el objeto correspondiente en el arreglo esperado. Esto es útil si se desea verificar que dos arreglos coinciden en el número de sus elementos, opuesto a <code>arrayContaining</code>, lo cual permite que el arreglo recibido contenga elementos adicionales.</p>
<p>Se puede hacer match de propiedades a través de sus valores o con matchers.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> casaEnVenta = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">habitaciones</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">colorPared</span>: <span class="hljs-string">'blanco'</span>,
  },
};
<span class="hljs-keyword">const</span> casaDeseada = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">colorPared</span>: expect.stringMatching(<span class="hljs-regexp">/blanco|amarillo/</span>),
  },
};

test(<span class="hljs-string">'la casa tiene las propiedades deseadas'</span>, () =&gt; {
  expect(casaEnVenta).toMatchObject(casaDeseada);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject aplicado a arreglos'</span>, () =&gt; {
  test(<span class="hljs-string">'el número de elementos debe coincidir'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "hará match de objetos recibidos cuyas propiedades no están en el objeto esperado."</span>
  test(<span class="hljs-string">'.toMatchObject no permite elementos extra'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject es llamado para cada elemento, de modo que las propiedades extra del objeto no importan'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertypathllave-valor"></a><code>.toHaveProperty(pathLlave, valor)</code> <a class="hash-link" href="#tohavepropertypathllave-valor">#</a></h3>
<p>Utilice <code>.toHaveProperty</code> para verificar si la propiedad en la referencia de <code>pathLlave</code> existe para un objeto dado. Para verificar las propiedades anidadas de un objeto, utilice <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> para referencias profundas.</p>
<p>Opcionalmente, se puede proveer un <code>valor</code> para verificar si está presente en el <code>pathLlave</code> del objeto objetivo. Este método utiliza 'igualdad profunda' (cómo <code>toEqual()</code>) y compara por igualdad a todos los campos de forma recursiva.</p>
<p>El siguiente ejemplo contiene un objeto <code>casaEnVenta</code> con propiedades anidadas. Estamos usando <code>toHaveProperty</code> para verificar la existencia y los valores de varias propiedades en el objeto.</p>
<pre><code class="language-js"><span class="hljs-comment">// Objeto que contiene las propiedades de casa que se desean probar</span>
<span class="hljs-keyword">const</span> casaEnVenta = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">habitaciones</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">colorPared</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Referencia simple</span>
  expect(casaEnVenta).toHaveProperty(<span class="hljs-string">'bañera'</span>);
  expect(casaEnVenta).toHaveProperty(<span class="hljs-string">'habitaciones'</span>, <span class="hljs-number">4</span>);

  expect(casaEnVenta).not.toHaveProperty(<span class="hljs-string">'piscina'</span>);

  <span class="hljs-comment">// Referencia profuna ocupando notación dot</span>
  expect(casaEnVenta).toHaveProperty(<span class="hljs-string">'cocina.area'</span>, <span class="hljs-number">20</span>);
  expect(casaEnVenta).toHaveProperty(<span class="hljs-string">'cocina.amenidades'</span>, [
    <span class="hljs-string">'horno'</span>,
    <span class="hljs-string">'estufa'</span>,
    <span class="hljs-string">'lavadora'</span>,
  ]);

  expect(casaEnVenta).not.toHaveProperty(<span class="hljs-string">'cocina.abierta'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/es-ES/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>Opcionalmente, se puede nombrar explicitamente el nombre del snapshot. Si no se especifica, el nombre se infiere de la prueba.</p>
<p><em>Nota: Las pruebas de snapshot son comúnmente usadas con componentes de React, sin embargo cualquier valor serializable puede utilizarse como snapshot.</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>También bajo el alias: <code>.toThrowError(error)</code></p>
<p>Utilice <code>.toThrow</code> en una prueba para verificar que una función arroja un error cuando se llama. Por ejemplo, si deseamos probar que <code>beberSabor('pulpo')</code> arroja un error, porque el sabor a pulpo es demasiado repugnante para beber, podemos escribir:</p>
<pre><code class="language-js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }).toThrow();
});
</code></pre>
<p>Si deseas verificar que se arroja cierto error en especifico, se le puede proveer un argumento a <code>toThrow</code>. El argumento puede ser una cadena representando el mensaje del error, la clase del error, o una expresión regular regex que coincida con el error. Por ejemplo, digamos que el código de <code>beberSabor</code> es el siguiente:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>Podríamos probar que este error lanza una excepción de varias formas:</p>
<pre><code class="language-js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  <span class="hljs-comment">// Probar el mensaje de error</span>
  expect(beberPulpo).toThrowError(<span class="hljs-string">'guac! sabor a pulpo'</span>);

  <span class="hljs-comment">// Probar que el mensaje de error contiene "guac" en algún lugar del mensaje</span>
  expect(beberPulpo).toThrowError(<span class="hljs-regexp">/guac/</span>);

  <span class="hljs-comment">// Probar que arroja un error ErrorSaborRepugnante</span>
  expect(beberPulpo).toThrowError(ErrorSaborRepugnante);
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>Utilice <code>.toThrowErrorMatchingSnapshot</code> para probar que una función arroja un error igual al snapshot más reciente cuando es llamada. Por ejemplo, digamos que tienes una función <code>beberSabor</code> que arroja un error cuando el sabor es <code>'pulpo'</code>, y su código es el siguiente:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>El test para esta función se verá así:</p>
<pre><code class="language-js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  expect(beberPulpo).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Y generará el siguiente snapshot:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>Echa un ojo a <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a> para más información sobre tests de instantánea.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/es-ES/getting-started.html">Getting Started</a><a href="/jest/docs/es-ES/snapshot-testing.html">Guides</a><a href="/jest/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/es-ES/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>