<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Cuando usted escribe pruebas, suele ser necesario revisar que los valores mantengan ciertas condiciones. `expect` le da acceso a un número de “correspondencias” que le permite validar diferentes aspectos."/><meta property="og:image" content="https://facebook.github.io/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/jest/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/es-ES/getting-started.html" target="_self">Documentación</a></li><li><a href="/jest/docs/es-ES/api.html" target="_self">API</a></li><li><a href="/jest/es-ES/help.html" target="_self">Ayuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/jest-platform.html">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/es6-class-mocks.html">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/puppeteer.html">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/troubleshooting.html">Troubleshooting</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/es-ES/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/cli.html">Jest CLI Options</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/ExpectAPI.md" target="_blank">Edit</a><h1>Expect</h1></header><article><div><span><p>Cuando usted escribe pruebas, suele ser necesario revisar que los valores mantengan ciertas condiciones. <code>expect</code> le da acceso a un número de “correspondencias” que le permite validar diferentes aspectos.</p>
<h2><a class="anchor" aria-hidden="true" name="metodos"></a><a href="#metodos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Métodos</h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" aria-hidden="true" name="referencia"></a><a href="#referencia" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referencia</h2>
<h3><a class="anchor" aria-hidden="true" name="expectvalue"></a><a href="#expectvalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect(value)</code></h3>
<p>La función <code>expect</code> se utiliza cada vez que desea testear un valor. Rara vez llamarás <code>expect</code> por si mismo. En lugar de esto, utilizará <code>expect</code> junto a una función &quot;matcher&quot; para afirmar algo sobre el valor.</p>
<p>Es más fácil entenderlo con este ejemplo. Digamos que tiene un método <code>bestLaCroixFlavor()</code> el cual, se supone, arrojará la cuerda <code>'grapefruit'</code>. Así es cómo sería el test:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'el mejor sabor es de melocotón'</span>, () =&gt; {
  expect(mejorSabor()).toBe(<span class="hljs-string">'melocotón'</span>);
});
</code></pre>
<p>En este caso, <code>toBe</code> es la función comparadora. Hay muchas funciones comparadoras diferentes, documentadas más abajo, para dejarle probar diferentes cosas.</p>
<p>El argumento a <code>expect</code> debería ser el valor que su código produzca, y cualquier argumento para el comparador debería ser el valor correcto. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</p>
<h3><a class="anchor" aria-hidden="true" name="expectextendmatchers"></a><a href="#expectextendmatchers" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.extend(matchers)</code></h3>
<p>Puedes utilizar <code>expect.extend</code> para añadir tus propios comparadores a Jest. Por ejemplo, supongamos que usted está testeando una biblioteca de teoría de números y afirma frecuentemente que los números son divisibles por otros números. You could abstract that into a <code>toBeDivisibleBy</code> matcher:</p>
<pre><code class="hljs css js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = received % argument == <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Los comparadores deben devolver un objeto con dos parámetros. <code>pass</code> indicates whether there was a match or not, and <code>message</code> provides a function with no arguments that returns an error message in case of failure. Thus, when <code>pass</code> is false, <code>message</code> should return the error message for when <code>expect(x).yourMatcher()</code> fails. And when <code>pass</code> is true, <code>message</code> should return the error message for when <code>expect(x).not.yourMatcher()</code> fails.</p>
<p>Éstas funciones auxiliares se pueden encontrar dentro de <code>this</code> como comparador personalizado:</p>
<h4><a class="anchor" aria-hidden="true" name="thisisnot"></a><a href="#thisisnot" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.isNot</code></h4>
<p>Un boolean para dejarle saber que esta correspondencia fue llamada con el modificador invalidado <code>.not</code> permitiéndole invertir su afirmación.</p>
<h4><a class="anchor" aria-hidden="true" name="thisequalsa-b"></a><a href="#thisequalsa-b" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.equals(a, b)</code></h4>
<p>Esta es una función de equidad que retornará <code>true</code> si dos objetos tienen el mismo valor (recurrentemente).</p>
<h4><a class="anchor" aria-hidden="true" name="thisutils"></a><a href="#thisutils" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.utils</code></h4>
<p>There are a number of helpful tools exposed on <code>this.utils</code> primarily consisting of the exports from <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>The most useful ones are <code>matcherHint</code>, <code>printExpected</code> and <code>printReceived</code> to format the error messages nicely. For example, take a look at the implementation for the <code>toBe</code> matcher:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = <span class="hljs-built_in">Object</span>.is(received, expected);

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) +
          <span class="hljs-string">'\n\n'</span> +
          <span class="hljs-string">`Expected value to not be (using Object.is):\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
          <span class="hljs-string">`Received:\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
            <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
          });
          <span class="hljs-keyword">return</span> (
            <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) +
            <span class="hljs-string">'\n\n'</span> +
            <span class="hljs-string">`Expected value to be (using Object.is):\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
            <span class="hljs-string">`Received:\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
            (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>)
          );
        };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Esto mostrará algo así:</p>
<pre><code class="hljs css bash">  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      <span class="hljs-string">"banana"</span>
    Received:
      <span class="hljs-string">"apple"</span>
</code></pre>
<p>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. Debe elaborar un mensaje de error preciso para asegurarse de que los usuarios de sus afirmaciones modificadas tengan una buena experiencia de desarrollador.</p>
<h3><a class="anchor" aria-hidden="true" name="expectanything"></a><a href="#expectanything" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.anything()</code></h3>
<p><code>expect.anything()</code> aprobará cualquier cosa excepto <code>null</code> o <code>undefined</code>. You can use it inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a literal value. For example, if you want to check that a mock function is called with a non-null argument:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectanyconstructor"></a><a href="#expectanyconstructor" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.any(constructor)</code></h3>
<p><code>expect.any(constructor)</code> matches anything that was created with the given constructor. You can use it inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a literal value. Por ejemplo, si desea controlar que se denomina una función de prueba con un número:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectarraycontainingarray"></a><a href="#expectarraycontainingarray" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.arrayContaining(array)</code></h3>
<p><code>expect.arrayContaining(array)</code> matches a received array which contains all of the elements in the expected array. That is, the expected array is a <strong>subset</strong> of the received array. Por esta razón, combina con una matriz recibida que consta con elementos <strong>not</strong> en la matriz esperada.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<pre><code class="hljs css js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectassertionsnumber"></a><a href="#expectassertionsnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.assertions(number)</code></h3>
<p><code>expect.assertions(number)</code> verifies that a certain number of assertions are called during a test. Esto es útil frecuentemente cuando se prueba el código asíncrono con el fin de asegurarnos de que las aserciones en una devolución de llamada realmente se invocaron.</p>
<p>For example, let's say that we have a function <code>doAsync</code> that receives two callbacks <code>callback1</code> and <code>callback2</code>, it will asynchronously call both of them in an unknown order. Podemos comprobarlo con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'doAsync llama a ambos callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>La llamada de <code>expect.assertions(2)</code> asegura que ambas devoluciones de llamada son efectivamente ejecutadas.</p>
<h3><a class="anchor" aria-hidden="true" name="expecthasassertions"></a><a href="#expecthasassertions" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.hasAssertions()</code></h3>
<p><code>expect.hasAssertions()</code> verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</p>
<p>Por ejemplo, digamos que tenemos unas pocas funciones y todas tratan con un estado. <code>prepareState</code> calls a callback with a state object, <code>validateState</code> runs on that state object, and <code>waitOnState</code> returns a promise that waits until all <code>prepareState</code> callbacks complete. Podemos comprobarlo con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'prepareState prepara un estado valido'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(estado)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>The <code>expect.hasAssertions()</code> call ensures that the <code>prepareState</code> callback actually gets called.</p>
<h3><a class="anchor" aria-hidden="true" name="expectobjectcontainingobject"></a><a href="#expectobjectcontainingobject" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.objectContaining(object)</code></h3>
<p><code>expect.objectContaining(object)</code> matches any received object that recursively matches the expected properties. That is, the expected object is a <strong>subset</strong> of the received object. Por lo tanto, coincide con un objeto aceptado que contiene propiedades que ** not ** en el objeto esperado.</p>
<p>Instead of literal property values in the expected object, you can use matchers, <code>expect.anything()</code>, and so on.</p>
<p>For example, let's say that we expect an <code>onPress</code> function to be called with an <code>Event</code> object, and all we need to verify is that the event has <code>event.x</code> and <code>event.y</code> properties. Puedes hacer esto con:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
      <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
    }),
  );
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectstringcontainingstring"></a><a href="#expectstringcontainingstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringContaining(string)</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-1900"></a><a href="#disponible-en-jest-1900" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>19.0.0+</strong></h5>
<p><code>expect.stringContaining(string)</code> matches any received string that contains the exact expected string.</p>
<h3><a class="anchor" aria-hidden="true" name="expectstringmatchingregexp"></a><a href="#expectstringmatchingregexp" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringMatching(regexp)</code></h3>
<p><code>expect.stringMatching(regexp)</code> matches any received string that matches the expected regexp.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para que coincida con un elemento en <code>arrayContaining</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<p>This example also shows how you can nest multiple asymmetric matchers, with <code>expect.stringMatching</code> inside the <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectaddsnapshotserializerserializer"></a><a href="#expectaddsnapshotserializerserializer" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.addSnapshotSerializer(serializer)</code></h3>
<p>You can call <code>expect.addSnapshotSerializer</code> to add a module that formats application-specific data structures.</p>
<p>For an individual test file, an added module precedes any modules from <code>snapshotSerializers</code> configuration, which precede the default snapshot serializers for built-in JavaScript types and for React elements. The last module added is the first module tested.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test</span>
</code></pre>
<p>If you add a snapshot serializer in individual test files instead of to adding it to <code>snapshotSerializers</code> configuration:</p>
<ul>
<li>Haces la dependencia explícita en lugar de implícita.</li>
<li>You avoid limits to configuration that might cause you to eject from <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/es-ES/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" aria-hidden="true" name="not"></a><a href="#not" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.not</code></h3>
<p>If you know how to test something, <code>.not</code> lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'el mejor sabor no es coco'</span>, () =&gt; {
  expect(mejorSaborLaCroix()).not.toBe(<span class="hljs-string">'coco'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="resolves"></a><a href="#resolves" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.resolves</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-2000"></a><a href="#disponible-en-jest-2000" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>20.0.0+</strong></h5>
<p>Use <code>resolves</code> to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</p>
<p>For example, this code tests that the promise resolves and that the resulting value is <code>'lemon'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resuelve a limon'</span>, () =&gt; {
  <span class="hljs-comment">// Es esencial que se agregue un statement de return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to <a href="/jest/docs/es-ES/asynchronous.html#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternativamente, se puede usar <code>async/await</code> en combinación con <code>.resolves</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resuelve a limon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.not.toBe(<span class="hljs-string">'pulpo'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="rejects"></a><a href="#rejects" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.rejects</code></h3>
<h5><a class="anchor" aria-hidden="true" name="disponible-en-jest-2000"></a><a href="#disponible-en-jest-2000" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>disponible en Jest <strong>20.0.0+</strong></h5>
<p>Use <code>.rejects</code> to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</p>
<p>For example, this code tests that the promise rejects with reason <code>'octopus'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(
    <span class="hljs-string">'octopus'</span>,
  );
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to <a href="/jest/docs/es-ES/asynchronous.html#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.rejects</code>.</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobevalue"></a><a href="#tobevalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBe(value)</code></h3>
<p><code>toBe</code> just checks that a value is what you expect. It uses <code>Object.is</code> to check exact equality.</p>
<p>Por ejemplo, el código a continuación valida algunas propiedades del objeto <code>lata</code>:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> lata = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'pomelo'</span>,
  <span class="hljs-attr">onzas</span> : <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'la lata'</span>, () =&gt; {
  test(<span class="hljs-string">'tiene 12 onzas'</span>, () =&gt; {
    expect(lata.onzas).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'tiene un nombre sofisticado'</span>, () =&gt; {
    expect(lata.nombre).toBe(<span class="hljs-string">'pomelo'</span>);
  });
});
</code></pre>
<p>No utilices <code>toBe</code> con números de punto flotante. For example, due to rounding, in JavaScript <code>0.2 + 0.1</code> is not strictly equal to <code>0.3</code>. If you have floating point numbers, try <code>.toBeCloseTo</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalled"></a><a href="#tohavebeencalled" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalled()</code></h3>
<p>También bajo el alias: <code>.toBeCalled()</code></p>
<p>Usa <code>.toHaveBeenCalled</code> para asegurar que una función &quot;mock&quot; fue llamada.</p>
<p>For example, let's say you have a <code>drinkAll(drink, flavor)</code> function that takes a <code>drink</code> function and applies it to all available beverages. You might want to check that <code>drink</code> gets called for <code>'lemon'</code>, but not for <code>'octopus'</code>, because <code>'octopus'</code> flavor is really weird and why would anything be octopus-flavored? Puedes hacerlo con esta serie de tests:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'beberTodo'</span>, () =&gt; {
  test(<span class="hljs-string">'bebe algo con sabor a limon'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    beberTodo(beber, <span class="hljs-string">'limon'</span>);
    expect(beber).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'no bebe algo con sabor a pulpo'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> beber = jest.fn();
    drinkAll(beber, <span class="hljs-string">'pulpo'</span>);
    expect(beber).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledtimesnumber"></a><a href="#tohavebeencalledtimesnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledTimes(number)</code></h3>
<p>Use <code>.toHaveBeenCalledTimes</code> to ensure that a mock function got called exact number of times.</p>
<p>For example, let's say you have a <code>drinkEach(drink, Array&lt;flavor&gt;)</code> function that takes a <code>drink</code> function and applies it to array of passed beverages. Es probable que pida controlar que la función de bebida se hubiera llamado el número exacto de veces. You can do that with this test suite:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beberCada bebe cada bebida'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beber = jest.fn();
  beberCada(beber, [<span class="hljs-string">'limon'</span>, <span class="hljs-string">'pulpo'</span>]);
  expect(beber).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledwitharg1-arg2-"></a><a href="#tohavebeencalledwitharg1-arg2-" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.toBeCalledWith()</code></p>
<p>Use <code>.toHaveBeenCalledWith</code> to ensure that a mock function was called with specific arguments.</p>
<p>For example, let's say that you can register a beverage with a <code>register</code> function, and <code>applyToAll(f)</code> should apply the function <code>f</code> to all registered beverages. Para asegurarte que funciona, puedes escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'registro aplicado correctamente a La Croix naranja'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'naranja'</span>);
  registrar(bebida);
  <span class="hljs-keyword">const</span> f = jest.fn();
  aplicarATodo(f);
  expect(f).toHaveBeenCalledWith(bebida);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeenlastcalledwitharg1-arg2-"></a><a href="#tohavebeenlastcalledwitharg1-arg2-" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>If you have a mock function, you can use <code>.toHaveBeenLastCalledWith</code> to test what arguments it was last called with. For example, let's say you have a <code>applyToAllFlavors(f)</code> function that applies <code>f</code> to a bunch of flavors, and you want to ensure that when you call it, the last flavor it operates on is <code>'mango'</code>. Puedes escribir:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'aplicarATodosLosSabores deja el mango para el final'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = jest.fn();
  aplicarATodosLosSabores(bebida);
  expect(bebida).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeclosetonumero-numerodigitos"></a><a href="#tobeclosetonumero-numerodigitos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeCloseTo(número, númeroDigitos)</code></h3>
<p>Es una mala idea usar la igualdad exacta con los números de coma flotante Redondear significa que las cosas intuitivas fallan. Por ejemplo, esta prueba falla:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Falla!</span>
});
</code></pre>
<p>It fails because in JavaScript, <code>0.2 + 0.1</code> is actually <code>0.30000000000000004</code>. Sorry.</p>
<p>En su lugar, usa <code>.toBeCloseTo</code>. Use <code>numDigits</code> to control how many digits after the decimal point to check. For example, if you want to be sure that <code>0.2 + 0.1</code> is equal to <code>0.3</code> with a precision of 5 decimal digits, you can use this test:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'sumar funciona de manera sencilla con decimales simples'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>The default for <code>numDigits</code> is 2, which has proved to be a good default in most cases.</p>
<h3><a class="anchor" aria-hidden="true" name="tobedefined"></a><a href="#tobedefined" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeDefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable no sea undefined. For example, if you just want to check that a function <code>fetchNewFlavorIdea()</code> returns <em>something</em>, you can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'hay una nueva idea de sabor'</span>, () =&gt; {
  expect(conseguirNuevaIdeaSabor()).toBeDefined();
});
</code></pre>
<p>You could write <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, but it's better practice to avoid referring to <code>undefined</code> directly in your code.</p>
<h3><a class="anchor" aria-hidden="true" name="tobefalsy"></a><a href="#tobefalsy" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeFalsy()</code></h3>
<p>Use <code>.toBeFalsy</code> when you don't care what a value is, you just want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (!conseguirErrores()) {
  beberMasLaCroix();
}
</code></pre>
<p>You may not care what <code>getErrors</code> returns, specifically - it might return <code>false</code>, <code>null</code>, or ``, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beber LaCroix no provoca errores'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(conseguirErrores()).toBeFalsy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthannumero"></a><a href="#tobegreaterthannumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThan(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThan</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of more than 10 ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es mayor a 10'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthanorequalnumero"></a><a href="#tobegreaterthanorequalnumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThanOrEqual(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThanOrEqual</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of at least 12 ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es por lo menos 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthannumero"></a><a href="#tobelessthannumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThan(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThan</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of less than 20 ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es menor a 20'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthanorequalnumero"></a><a href="#tobelessthanorequalnumero" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThanOrEqual(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThanOrEqual</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of at most 12 ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onzas por lata es a lo mucho 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeinstanceofclass"></a><a href="#tobeinstanceofclass" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeInstanceOf(Class)</code></h3>
<p>Use <code>.toBeInstanceOf(Class)</code> to check that an object is an instance of a class. This matcher uses <code>instanceof</code> underneath.</p>
<pre><code class="hljs css js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// avienta error</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobenull"></a><a href="#tobenull" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNull()</code></h3>
<p><code>.toBeNull()</code> is the same as <code>.toBe(null)</code> but the error messages are a bit nicer. So use <code>.toBeNull()</code> when you want to check that something is null.</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop regresa null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobetruthy"></a><a href="#tobetruthy" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeTruthy()</code></h3>
<p>Use <code>.toBeTruthy</code> when you don't care what a value is, you just want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (infoSed()) {
  beberMasLaCroix();
}
</code></pre>
<p>You may not care what <code>thirstInfo</code> returns, specifically - it might return <code>true</code> or a complex object, and your code would still work. So if you just want to test that <code>thirstInfo</code> will be truthy after drinking some La Croix, you could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'beber La Croix lleva a conseguir info de sed'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(infoSed()).toBeTruthy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" name="tobeundefined"></a><a href="#tobeundefined" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeUndefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable es undefined. For example, if you want to check that a function <code>bestDrinkForFlavor(flavor)</code> returns <code>undefined</code> for the <code>'octopus'</code> flavor, because there is no good octopus-flavored drink:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'la mejor bebida con sabor a pulpo es undefined'</span>, () =&gt; {
  expect(mejorBebidaPorSabor(<span class="hljs-string">'pulpo'</span>)).toBeUndefined();
});
</code></pre>
<p>You could write <code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>, but it's better practice to avoid referring to <code>undefined</code> directly in your code.</p>
<h3><a class="anchor" aria-hidden="true" name="tocontainitem"></a><a href="#tocontainitem" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContain(item)</code></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'la lista de sabores contiene lima'</span>, () =&gt; {
  expect(conseguirTodosSabores()).toContain(<span class="hljs-string">'lima'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tocontainequalitem"></a><a href="#tocontainequalitem" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContainEqual(item)</code></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa y no es agría'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> miBebida = {<span class="hljs-attr">deliciosa</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">agria</span>: <span class="hljs-literal">false</span>};
    expect(misBebidas()).toContainEqual(miBebida);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="toequalvalue"></a><a href="#toequalvalue" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toEqual(value)</code></h3>
<p>Utilice <code>.toEqual</code> cuando se desee verificar que dos objetos tienen el mismo valor. This matcher recursively checks the equality of all fields, rather than checking for object identity—this is also known as &quot;deep equal&quot;. For example, <code>toEqual</code> and <code>toBe</code> behave differently in this test suite, so all the tests pass:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> lata1 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> lata2 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'las latas de La Croix en mi escritorio'</span>, () =&gt; {
  test(<span class="hljs-string">'tienen las mismas propiedades'</span>, () =&gt; {
    expect(lata1).toEqual(lata2);
  });
  test(<span class="hljs-string">'no son la misma lata'</span>, () =&gt; {
    expect(lata1).not.toBe(lata2);
  });
});
</code></pre>
<blockquote>
<p>Nota: <code>.toEqual</code> no realizara una verificación de <em>igualdad profunda</em> para dos errores. Only the <code>message</code> property of an Error is considered for equality. It is recommended to use the <code>.toThrow</code> matcher for testing against errors.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tohavelengthnumber"></a><a href="#tohavelengthnumber" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLength(number)</code></h3>
<p>Use <code>.toHaveLength</code> to check that an object has a <code>.length</code> property and it is set to a certain numeric value.</p>
<p>Es especialmente útil para verificar el tamaño de cadenas o arreglos.</p>
<pre><code class="hljs css js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchregexporstring"></a><a href="#tomatchregexporstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatch(regexpOrString)</code></h3>
<p>Utilice <code>.toMatch</code> para verificar que la cadena coincida con una expresión regular (Regex).</p>
<p>For example, you might not know what exactly <code>essayOnTheBestFlavor()</code> returns, but you know it's a really long string, and the substring <code>grapefruit</code> should be in there somewhere. Podemos probarlo con:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'un ensayo sobre el mejor sabor'</span>, () =&gt; {
  test(<span class="hljs-string">'menciona toronja'</span>, () =&gt; {
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-regexp">/toronja/</span>);
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'toronja'</span>));
  });
});
</code></pre>
<p>Este método acepta también una cadena, con la que va a intentar coincidir:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'las toronjas son saludables'</span>, () =&gt; {
  test(<span class="hljs-string">'las toronjas son frutas'</span>, () =&gt; {
    expect(<span class="hljs-string">'toronjas'</span>).toMatch(<span class="hljs-string">'fruta'</span>);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchobjectobject"></a><a href="#tomatchobjectobject" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchObject(object)</code></h3>
<p>Use <code>.toMatchObject</code> to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are <strong>not</strong> in the expected object.</p>
<p>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the <code>toMatchObject</code> sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to <code>arrayContaining</code>, which allows for extra elements in the received array.</p>
<p>Se puede hacer match de propiedades a través de sus valores o con matchers.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> casaEnVenta = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">habitaciones</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">colorPared</span>: <span class="hljs-string">'blanco'</span>,
  },
};
<span class="hljs-keyword">const</span> casaDeseada = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">colorPared</span>: expect.stringMatching(<span class="hljs-regexp">/blanco|amarillo/</span>),
  },
};

test(<span class="hljs-string">'la casa tiene las propiedades deseadas'</span>, () =&gt; {
  expect(casaEnVenta).toMatchObject(casaDeseada);
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that</span>
  <span class="hljs-comment">// are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span>}]).toMatchObject([
      {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>},
      {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>},
    ]);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavepropertypathllave-valor"></a><a href="#tohavepropertypathllave-valor" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveProperty(pathLlave, valor)</code></h3>
<p>Use <code>.toHaveProperty</code> to check if property at provided reference <code>keyPath</code> exists for an object. For checking deeply nested properties in an object you may use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> or an array containing the keyPath for deep references.</p>
<p>Optionally, you can provide a <code>value</code> to check if it's equal to the value present at <code>keyPath</code> on the target object. This matcher uses 'deep equality' (like <code>toEqual()</code>) and recursively checks the equality of all fields.</p>
<p>El siguiente ejemplo contiene un objeto <code>casaEnVenta</code> con propiedades anidadas. We are using <code>toHaveProperty</code> to check for the existence and values of various properties in the object.</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);

  <span class="hljs-comment">// Deep referencing using an array containing the keyPath</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'area'</span>], <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(
    [<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>],
    [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
  );
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>, <span class="hljs-number">0</span>], <span class="hljs-string">'oven'</span>);

  expect(houseForSale).not.toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'open'</span>]);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchsnapshotoptionalstring"></a><a href="#tomatchsnapshotoptionalstring" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchSnapshot(optionalString)</code></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/es-ES/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>You can also specify an optional snapshot name. Otherwise, the name is inferred from the test.</p>
<p><em>Nota: Si bien la prueba de instantáneas se usa con mayor frecuencia con los componentes de React, cualquier valor serializable se puede utilizar como una instantánea.</em></p>
<h3><a class="anchor" aria-hidden="true" name="tothrowerror"></a><a href="#tothrowerror" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrow(error)</code></h3>
<p>También bajo el alias: <code>.toThrowError(error)</code></p>
<p>Utilice <code>.toThrow</code> en una prueba para verificar que una función arroja un error cuando se llama. For example, if we want to test that <code>drinkFlavor('octopus')</code> throws, because octopus flavor is too disgusting to drink, we could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }).toThrow();
});
</code></pre>
<p>If you want to test that a specific error gets thrown, you can provide an argument to <code>toThrow</code>. The argument can be a string for the error message, a class for the error, or a regex that should match the error. For example, let's say that <code>drinkFlavor</code> is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>Podríamos probar que este error lanza una excepción de varias formas:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  <span class="hljs-comment">// Probar el mensaje de error</span>
  expect(beberPulpo).toThrowError(<span class="hljs-string">'guac! sabor a pulpo'</span>);

  <span class="hljs-comment">// Probar que el mensaje de error contiene "guac" en algún lugar del mensaje</span>
  expect(beberPulpo).toThrowError(<span class="hljs-regexp">/guac/</span>);

  <span class="hljs-comment">// Probar que arroja un error ErrorSaborRepugnante</span>
  expect(beberPulpo).toThrowError(ErrorSaborRepugnante);
});
</code></pre>
<blockquote>
<p>Nota: debe envolver el código en una función, al lo contrario el error no se detectará y la afirmación fallará.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tothrowerrormatchingsnapshot"></a><a href="#tothrowerrormatchingsnapshot" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingSnapshot()</code></h3>
<p>Use <code>.toThrowErrorMatchingSnapshot</code> to test that a function throws an error matching the most recent snapshot when it is called. For example, let's say you have a <code>drinkFlavor</code> function that throws whenever the flavor is <code>'octopus'</code>, and is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>El test para esta función se verá así:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  expect(beberPulpo).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Y generará el siguiente snapshot:</p>
<pre><code class="hljs css js">exports[<span class="hljs-string">`drinking flavors throws on octopus 1`</span>] = <span class="hljs-string">`"yuck, octopus flavor"`</span>;
</code></pre>
<p>Check out <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a> for more information on snapshot testing.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/es-ES/getting-started.html">Getting Started</a><a href="/jest/docs/es-ES/snapshot-testing.html">Guides</a><a href="/jest/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/es-ES/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script></body></html>