<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>The Jest Object · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="The Jest Object · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="El objeto `jest` se encuentra de manera automática en el scope de cada archivo de prueba. Los métodos dentro del objeto `jest` ayudan a crear funciones simuladas mock y controlar el comportamiento general de Jest."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/es-ES/getting-started.html" target="_self">Documentación</a></li><li><a href="/jest/docs/es-ES/api.html" target="_self">API</a></li><li><a href="/jest/es-ES/help.html" target="_self">Ayuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/mock-function-api.html">Mock Functions</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/es-ES/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>The Jest Object</h1></header><article><div><span><p>El objeto <code>jest</code> se encuentra de manera automática en el scope de cada archivo de prueba. Los métodos dentro del objeto <code>jest</code> ayudan a crear funciones simuladas mock y controlar el comportamiento general de Jest.</p>
<h2><a class="anchor" name="metodos"></a>Métodos <a class="hash-link" href="#metodos">#</a></h2>
<ul>
<li><a href="#jestclearalltimers"><code>jest.clearAllTimers()</code></a></li>
<li><a href="#jestdisableautomock"><code>jest.disableAutomock()</code></a></li>
<li><a href="#jestenableautomock"><code>jest.enableAutomock()</code></a></li>
<li><a href="#jestfnimplementation"><code>jest.fn(implementation)</code></a></li>
<li><a href="#jestismockfunctionfn"><code>jest.isMockFunction(fn)</code></a></li>
<li><a href="#jestgenmockfrommodulemodulename"><code>jest.genMockFromModule(moduleName)</code></a></li>
<li><a href="#jestmockmodulename-factory-options"><code>jest.mock(moduleName, factory, options)</code></a></li>
<li><a href="#jestunmockmodulename"><code>jest.unmock(moduleName)</code></a></li>
<li><a href="#jestdomockmodulename-factory-options"><code>jest.doMock(moduleName, factory, options)</code></a></li>
<li><a href="#jestdontmockmodulename"><code>jest.dontMock(moduleName)</code></a></li>
<li><a href="#jestclearallmocks"><code>jest.clearAllMocks()</code></a></li>
<li><a href="#jestresetallmocks"><code>jest.resetAllMocks()</code></a></li>
<li><a href="#jestrestoreallmocks"><code>jest.restoreAllMocks()</code></a></li>
<li><a href="#jestresetmodules"><code>jest.resetModules()</code></a></li>
<li><a href="#jestrunallticks"><code>jest.runAllTicks()</code></a></li>
<li><a href="#jestrunalltimers"><code>jest.runAllTimers()</code></a></li>
<li><a href="#jestadvancetimersbytimemstorun"><code>jest.advanceTimersByTime(msToRun)</code></a></li>
<li><a href="#jestrunonlypendingtimers"><code>jest.runOnlyPendingTimers()</code></a></li>
<li><a href="#jestsetmockmodulename-moduleexports"><code>jest.setMock(moduleName, moduleExports)</code></a></li>
<li><a href="#jestsettimeouttimeout"><code>jest.setTimeout(timeout)</code></a></li>
<li><a href="#jestusefaketimers"><code>jest.useFakeTimers()</code></a></li>
<li><a href="#jestuserealtimers"><code>jest.useRealTimers()</code></a></li>
<li><a href="#jestspyonobject-methodname"><code>jest.spyOn(object, methodName)</code></a></li>
</ul>
<hr>
<h2><a class="anchor" name="referencia"></a>Referencia <a class="hash-link" href="#referencia">#</a></h2>
<h3><a class="anchor" name="jestclearalltimers"></a><code>jest.clearAllTimers()</code> <a class="hash-link" href="#jestclearalltimers">#</a></h3>
<p>Remueve cualquier temporizador pendiente en el sistema de temporizadores.</p>
<p>Esto significa que, cualquier temporizador que haya sido programado (pero no se ha ejecutado aún), será borrado y no tendrá la oportunidad de ejecutarse en un futuro.</p>
<h3><a class="anchor" name="jestdisableautomock"></a><code>jest.disableAutomock()</code> <a class="hash-link" href="#jestdisableautomock">#</a></h3>
<p>Deshabilita la simulación mock automática en el cargador de módulos.</p>
<p>Una vez que se haya ejecutado este método, todas las llamadas a <code>require()</code> regresarán el módulo real (en lugar de una simulación mock).</p>
<p>Esto es especialmente útil en el caso donde las dependencias que se desean simular es mucho menor a las dependencias que no se desean simular. Por ejemplo, si se escribe un test para un módulo que ocupa una gran cantidad de dependencias que se podrían clasificar como &quot;detalles de la implementación&quot;, es probable que no se deseen simular.</p>
<p>Ejemplos de dependencias que podrían considerarse &quot;detalles de la implementación&quot; pueden ser módulos nativos del lenguaje (como métodos de Array.prototype), módulos de utilidad muy comunes (como underscore/lo-dash, utilidades de arreglos, etc) y librerías completas como React.js.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<p><em>Nota: este método se llamaba anteriormente <code>autoMockOff</code>. Cuando se usa <code>babel-jest</code>, las llamadas a <code>disableAutomock</code> se llevan automáticamente al principio del bloque de código. Si se desea evitar este comportamiento, se debe usar <code>autoMockOff</code>.</em></p>
<h3><a class="anchor" name="jestenableautomock"></a><code>jest.enableAutomock()</code> <a class="hash-link" href="#jestenableautomock">#</a></h3>
<p>Habilita la simulación mock automática en el cargador de módulos.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<p><em>Nota: este método se llamaba anteriormente <code>autoMockOn</code>. Cuando se usa <code>babel-jest</code>, las llamadas a <code>enableAutomock</code> se llevan automáticamente al principio del bloque de código. Si se desea evitar este comportamiento, se debe usar <code>autoMockOn</code>.</em></p>
<h3><a class="anchor" name="jestfnimplementation"></a><code>jest.fn(implementation)</code> <a class="hash-link" href="#jestfnimplementation">#</a></h3>
<p>Returns a new, unused <a href="MockFunctionAPI.html">mock function</a>. Optionally takes a mock implementation.</p>
<pre><code class="language-js">  <span class="hljs-keyword">const</span> mockFn = jest.fn();
  mockFn();
  expect(mockFn).toHaveBeenCalled();

  <span class="hljs-comment">// With a mock implementation:</span>
  <span class="hljs-keyword">const</span> returnsTrue = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);
  <span class="hljs-built_in">console</span>.log(returnsTrue()); <span class="hljs-comment">// true;</span>
</code></pre>
<h3><a class="anchor" name="jestismockfunctionfn"></a><code>jest.isMockFunction(fn)</code> <a class="hash-link" href="#jestismockfunctionfn">#</a></h3>
<p>Determina si la función dada es una función simulada.</p>
<h3><a class="anchor" name="jestgenmockfrommodulemodulename"></a><code>jest.genMockFromModule(moduleName)</code> <a class="hash-link" href="#jestgenmockfrommodulemodulename">#</a></h3>
<p>Dado el nombre de un modulo, usa el sistema automático de simulación mock para generar una versión mock del modulo deseado.</p>
<p>This is useful when you want to create a <a href="/jest/docs/es-ES/manual-mocks.html">manual mock</a> that extends the automatic mock's behavior.</p>
<h3><a class="anchor" name="jestmockmodulename-factory-options"></a><code>jest.mock(moduleName, factory, options)</code> <a class="hash-link" href="#jestmockmodulename-factory-options">#</a></h3>
<p>Crea una simulación mock de un modulo auto-mocked cuando es requerido. Las opciones <code>factory</code> y <code>options</code> son opcionales. Por ejemplo:</p>
<pre><code class="language-js"><span class="hljs-comment">// banana.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'banana'</span>;

<span class="hljs-comment">// __tests__/test.js</span>
jest.mock(<span class="hljs-string">'../banana'</span>);

<span class="hljs-keyword">const</span> banana = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../banana'</span>); <span class="hljs-comment">// banana will be explicitly mocked.</span>

banana(); <span class="hljs-comment">// will return 'undefined' because the function is auto-mocked.</span>
</code></pre>
<p>El segundo argumento puede usarse para especificar que se ejecute una fábrica de módulos de manera explicita en lugar de la funcionalidad de simulación mock automática de Jest:</p>
<pre><code class="language-js">jest.mock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);
});

<span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>); <span class="hljs-comment">// This runs the function specified as second argument to `jest.mock`.</span>
moduleName(); <span class="hljs-comment">// Will return '42';</span>
</code></pre>
<p>El tercer argumento puede ser usado para crear simulaciones mock virtuales, es decir, mocks de módulos que no existen en ninguna parte del sistema:</p>
<pre><code class="language-js">jest.mock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
  <span class="hljs-comment">/*
   * Custom implementation of a module that doesn't exist in JS,
   * like a generated module or a native module in react-native.
   */</span>
}, {<span class="hljs-attr">virtual</span>: <span class="hljs-literal">true</span>});
</code></pre>
<p><em>Advertencia: Importar un modulo en el archivo de configuración inicial (como se especifica en <code>setupTestFrameworkScriptFile</code>) previene que se simule dicho modulo, así como cualquier otro módulo que éste importe.</em></p>
<p>Los módulos que son simulados vía <code>jest.mock</code> son solo simulados para el archivo que ejecuta <code>jest.mock</code>. Cualquier otro archivo que importe el modulo hará uso de la implementación original incluso si éste se ejecuta después de una prueba que use un mock para el mismo módulo.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestunmockmodulename"></a><code>jest.unmock(moduleName)</code> <a class="hash-link" href="#jestunmockmodulename">#</a></h3>
<p>Le indica al sistema de módulos que nunca debe regresar una versión simulada mock de un modulo en especifico cuando se importe vía <code>require()</code> (es decir, que siempre debe regresar el modulo real).</p>
<p>El uso más común de esta API es para especificar el modulo que se va a probar (y que por tanto no se desea simular automáticamente).</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestdomockmodulename-factory-options"></a><code>jest.doMock(moduleName, factory, options)</code> <a class="hash-link" href="#jestdomockmodulename-factory-options">#</a></h3>
<p>When using <code>babel-jest</code>, calls to <code>mock</code> will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</p>
<p>One example when this is useful is when you want to mock a module differently within the same file:</p>
<pre><code class="language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.resetModules();
});

test(<span class="hljs-string">'moduleName 1'</span>, () =&gt; {
  jest.doMock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
    <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1</span>);
  });
  <span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>);
  expect(moduleName()).toEqual(<span class="hljs-number">1</span>);
});

test(<span class="hljs-string">'moduleName 2'</span>, () =&gt; {
  jest.doMock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
    <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">2</span>);
  });
  <span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>);
  expect(moduleName()).toEqual(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestdontmockmodulename"></a><code>jest.dontMock(moduleName)</code> <a class="hash-link" href="#jestdontmockmodulename">#</a></h3>
<p>When using <code>babel-jest</code>, calls to <code>unmock</code> will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestclearallmocks"></a><code>jest.clearAllMocks()</code> <a class="hash-link" href="#jestclearallmocks">#</a></h3>
<p>Borra las propiedades <code>mock.calls</code> y <code>mock.instances</code> de todos los mocks. Es el equivalente a llamar a <code>.mockClear()</code> en cada función simulada.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestresetallmocks"></a><code>jest.resetAllMocks()</code> <a class="hash-link" href="#jestresetallmocks">#</a></h3>
<p>Restablece el estado de todos los mock. Es el equivalente a llamar a <code>.mockReset()</code> en cada función simulada.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestrestoreallmocks"></a><code>jest.restoreAllMocks()</code> <a class="hash-link" href="#jestrestoreallmocks">#</a></h3>
<h5><a class="anchor" name="available-in-jest-2110"></a>available in Jest <strong>21.1.0+</strong> <a class="hash-link" href="#available-in-jest-2110">#</a></h5>
<p>Restores all mocks back to their original value. Equivalent to calling <code>.mockRestore</code> on every mocked function. Beware that <code>jest.restoreAllMocks()</code> only works when mock was created with <code>jest.spyOn</code>; other mocks will require you to manually restore them.</p>
<h3><a class="anchor" name="jestresetmodules"></a><code>jest.resetModules()</code> <a class="hash-link" href="#jestresetmodules">#</a></h3>
<p>Restablece el registro de módulos - el caché de todos los módulos importados. Esto es útil para aislar módulos donde estado local podría entrar en conflicto entre pruebas.</p>
<p>Ejemplo:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> sum1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
jest.resetModules();
<span class="hljs-keyword">const</span> sum2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
sum1 === sum2;
<span class="hljs-comment">// &gt; false (Both sum modules are separate "instances" of the sum module.)</span>
</code></pre>
<p>Ejemplo en una prueba:</p>
<pre><code class="language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.resetModules();
});

test(<span class="hljs-string">'works'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
});

test(<span class="hljs-string">'works too'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
  <span class="hljs-comment">// sum is a different copy of the sum module from the previous test.</span>
});
</code></pre>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestrunallticks"></a><code>jest.runAllTicks()</code> <a class="hash-link" href="#jestrunallticks">#</a></h3>
<p>Agota la cola de tareas <strong>micro</strong> (cuya interfaz en node es <code>process.nextTick</code>).</p>
<p>Cuando se llama a este API, todas las micro-tareas que estén en la cola de <code>process.nextTick</code> serán ejecutadas. De manera adicional, si esas micro-tareas mismas crean nuevas micro-tareas, éstas se agotaran continuamente hasta que no haya más micro-tareas en la cola.</p>
<h3><a class="anchor" name="jestrunalltimers"></a><code>jest.runAllTimers()</code> <a class="hash-link" href="#jestrunalltimers">#</a></h3>
<p>Agota la cola de tareas <strong>macro</strong> (es decir todas las tareas que hayan entrado a la cola de <code>setTimeout()</code>, <code>setInterval()</code>, y <code>setImmediate()</code>).</p>
<p>Cuando se llama a este API, todas las &quot;macro-tareas&quot; que estén en la cola de <code>setTimeout()</code> o <code>setInterval()</code> serán ejecutadas. De manera adicional, si esas macro-tareas mismas crean nuevas macro-tareas, éstas se agotaran continuamente hasta que no haya más micro-tareas en la cola.</p>
<p>Esto es útil para ejecutar setTimeouts de manera sincronía en una prueba para así verificar de manera sincronía acciones que ocurrirían después de que se ejecuten los callbacks de <code>setTimeout()</code> o <code>setInterval()</code>. See the <a href="/jest/docs/es-ES/timer-mocks.html">Timer mocks</a> doc for more information.</p>
<h3><a class="anchor" name="jestrunallimmediates"></a><code>jest.runAllImmediates()</code> <a class="hash-link" href="#jestrunallimmediates">#</a></h3>
<p>Agota todas las tareas en la cola de <code>setImmediate()</code>.</p>
<h3><a class="anchor" name="jestadvancetimersbytimemstorun"></a><code>jest.advanceTimersByTime(msToRun)</code> <a class="hash-link" href="#jestadvancetimersbytimemstorun">#</a></h3>
<h5><a class="anchor" name="renamed-in-jest-2130"></a>renamed in Jest <strong>21.3.0+</strong> <a class="hash-link" href="#renamed-in-jest-2130">#</a></h5>
<p>Also under the alias: <code>.runTimersToTime()</code></p>
<p>Ejecuta solo las tareas macro (es decir todas aquellas programadas por <code>setTimeout()</code>, <code>setInterval()</code> y <code>setImmediate()</code>).</p>
<p>When this API is called, all timers are advanced by <code>msToRun</code> milliseconds. All pending &quot;macro-tasks&quot; that have been queued via <code>setTimeout()</code> or <code>setInterval()</code>, and would be executed within this timeframe will be executed. Además si esas macro tareas programan nuevas macro tareas que se ejecutarían dentro del mismo plazo, éstas también se ejecutarán hasta que no haya más macro-tareas restantes en la cola. Esto se ejecutara en los mili segundos especificados en <code>msToRun</code>.</p>
<h3><a class="anchor" name="jestrunonlypendingtimers"></a><code>jest.runOnlyPendingTimers()</code> <a class="hash-link" href="#jestrunonlypendingtimers">#</a></h3>
<p>Ejecuta solo las macro-tareas que se encuentren pendientes (es decir, sólo las tareas que entraron a la cola vía <code>setTimeout()</code> o <code>setInterval()</code> hasta ese momento). Si cualquiera de esas macro-tareas crearon nuevas macro-tareas, éstas últimas no se ejecutarán en esta llamada.</p>
<p>Esto es útil para escenarios donde el modulo probado llama a <code>setTimeout()</code> y éste a su vez llama a <code>setTimeout()</code> de manera recursiva (de manera que las llamadas nunca terminan). En dichos escenarios, es útil poder avanzar en la linea de tiempo de ejecución un paso a la vez.</p>
<h3><a class="anchor" name="jestsetmockmodulename-moduleexports"></a><code>jest.setMock(moduleName, moduleExports)</code> <a class="hash-link" href="#jestsetmockmodulename-moduleexports">#</a></h3>
<p>Provee de manera especifica el modulo simulado mock que el sistema de módulos debe regresar para un modulo en especifico.</p>
<p>Hay ocasiones donde el modulo mock que se genera automáticamente por el sistema de módulos no es adecuado para las pruebas que se desean realizar. Normally under those circumstances you should write a <a href="/jest/docs/es-ES/manual-mocks.html">manual mock</a> that is more adequate for the module in question. Y sin embargo, en raras ocasiones, inclusive un mock manual puede no ser apropiado para los propósitos de la prueba, en cuyo caso se tiene que construir el mock dentro de la prueba.</p>
<p>En estos raros casos, se puede ocupar esta API para llenar de manera manual el registro del módulo mock en el sistema de módulos.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<p><em>Es importante notar que es mejor práctica ocupar <a href="#jestmockmodulename-factory-options"><code>jest.mock()</code></a>. El segundo argumento del API de <code>jest.mock</code> es una fábrica de modulos en lugar del objeto del modulo que se espera exportar.</em></p>
<h3><a class="anchor" name="jestsettimeouttimeout"></a><code>jest.setTimeout(timeout)</code> <a class="hash-link" href="#jestsettimeouttimeout">#</a></h3>
<p>Set the default timeout interval for tests and before/after hooks in milliseconds.</p>
<p><em>Note: The default timeout interval is 5 seconds if this method is not called.</em></p>
<p>Ejemplo:</p>
<pre><code class="language-js">jest.setTimeout(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1 second</span>
</code></pre>
<h3><a class="anchor" name="jestusefaketimers"></a><code>jest.useFakeTimers()</code> <a class="hash-link" href="#jestusefaketimers">#</a></h3>
<p>Indica a Jest que se deben ocupar versiones falsas de las funciones estándares de temporizadores (<code>setTimeout</code>, <code>setInterval</code>, <code>clearTimeout</code>, <code>clearInterval</code>, <code>nextTick</code>, <code>setImmediate</code> y <code>clearImmediate</code>).</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestuserealtimers"></a><code>jest.useRealTimers()</code> <a class="hash-link" href="#jestuserealtimers">#</a></h3>
<p>Indica a Jest que se deben ocupar las versiones reales de las funciones estándares de temporizadores.</p>
<p>Regresa el objeto <code>jest</code> para poder ser usado llamadas consecutivas.</p>
<h3><a class="anchor" name="jestspyonobject-methodname"></a><code>jest.spyOn(object, methodName)</code> <a class="hash-link" href="#jestspyonobject-methodname">#</a></h3>
<h5><a class="anchor" name="disponible-en-jest-1900"></a>disponible en Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponible-en-jest-1900">#</a></h5>
<p>Crea una función simulada de manera similar a <code>jest.fn</code> pero que permite también llevar un registro de llamadas a <code>object[methodName]</code>. Regresa una función mock.</p>
<p><em>Nota: Por defecto, <code>jest.spyOn</code> también llama al método <strong>spied</strong>. Este comportamiento es diferente de casi todas las otras librerías para pruebas. Si se desea remplazar la función original, se puede usar <code>jest.spyOn(object, methodName).mockImplementation(() =&gt; implementacionPropia)</code> o <code>object[methodName] = jest.fn(() =&gt; implementacionPropia);</code></em></p>
<p>Ejemplo:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> video = {
  play() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
};

<span class="hljs-built_in">module</span>.exports = video;
</code></pre>
<p>Prueba de ejemplo:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> video = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./video'</span>);

test(<span class="hljs-string">'plays video'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> spy = jest.spyOn(video, <span class="hljs-string">'play'</span>);
  <span class="hljs-keyword">const</span> isPlaying = video.play();

  expect(spy).toHaveBeenCalled();
  expect(isPlaying).toBe(<span class="hljs-literal">true</span>);

  spy.mockReset();
  spy.mockRestore();
});
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="mock-function-api.html">← Mock Functions</a><a class="docs-next button" href="configuration.html">Configuring Jest →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/es-ES/getting-started.html">Getting Started</a><a href="/jest/docs/es-ES/snapshot-testing.html">Guides</a><a href="/jest/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/es-ES/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>