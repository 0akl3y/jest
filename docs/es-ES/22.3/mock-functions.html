<html lang="es-ES"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Mock Functions · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Mock Functions · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Las funciones de simulación mock permiten probar los vínculos entre código deshaciéndose de la implementación real de una función, capturando llamadas a la función (y los parámetros de dicha llamada), capturando instancias de funciones de construcción cuando estas se crean instancias con `new`, y permitiendo configuración de valores de retorno al momento de probar."/><meta property="og:image" content="https://facebook.github.io/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/jest/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><a href="/jest/es-ES/versions.html"><h3>22.3</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/es-ES/22.3/getting-started.html" target="_self">Documentación</a></li><li><a href="/jest/docs/es-ES/22.3/api.html" target="_self">API</a></li><li><a href="/jest/es-ES/help.html" target="_self">Ayuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Introduction</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/es-ES/22.3/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/jest-platform.html">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/es6-class-mocks.html">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/puppeteer.html">
Usar con puppeteer</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/mongodb.html">Utilizando con MongoDB</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/troubleshooting.html">Troubleshooting</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/es-ES/22.3/cli.html">Jest CLI Options</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/MockFunctions.md" target="_blank">Edit</a><h1>Mock Functions</h1></header><article><div><span><p>Las funciones de simulación mock permiten probar los vínculos entre código deshaciéndose de la implementación real de una función, capturando llamadas a la función (y los parámetros de dicha llamada), capturando instancias de funciones de construcción cuando estas se crean instancias con <code>new</code>, y permitiendo configuración de valores de retorno al momento de probar.</p>
<p>Hay dos maneras de burlarse de las funciones: ya sea mediante la creación de una falsa función a utilizar en la prueba código o escribir un <a href="/jest/docs/es-ES/22.3/manual-mocks.html"><code>manual de simulacro</code></a> para anular una dependencia módulo.</p>
<h2><a class="anchor" aria-hidden="true" name="usando-una-funcion-mock"></a><a href="#usando-una-funcion-mock" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usando una función mock</h2>
<p>Supongamos se esta probando la implementación de una función <code>forEach</code> que invoca una función callback para cada objeto del arreglo que se provee.</p>
<pre><code class="hljs css javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">items, callback</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; items.length; index++) {
    callback(items[index]);
  }
}
</code></pre>
<p>Para probar esta función, podemos ocupar una función mock, e inspeccionar el estado del mock para asegurarnos que se llama a la función callback como es esperado.</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> mockCallback = jest.fn();
forEach([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], mockCallback);

<span class="hljs-comment">// The mock function is called twice</span>
expect(mockCallback.mock.calls.length).toBe(<span class="hljs-number">2</span>);

<span class="hljs-comment">// The first argument of the first call to the function was 0</span>
expect(mockCallback.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">0</span>);

<span class="hljs-comment">// The first argument of the second call to the function was 1</span>
expect(mockCallback.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">1</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="propiedad-mock"></a><a href="#propiedad-mock" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>propiedad <code>.mock</code></h2>
<p>Todas las funciones simuladas mock tienen la propiedad <code>.mock</code>, donde se guarda la información sobre como se ha llamado a esa función. La propiedad <code>.mock</code> guarda también el valor de <code>this</code> correspondiente a cada llamada, de modo que también se puede inspeccionar lo siguiente:</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> miMock = jest.fn();

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> miMock();
<span class="hljs-keyword">const</span> b = {};
<span class="hljs-keyword">const</span> bound = miMock.bind(b);
bound();

<span class="hljs-built_in">console</span>.log(miMock.mock.instances);
<span class="hljs-comment">// &gt; [ &lt;a&gt;, &lt;b&gt; ]</span>
</code></pre>
<p>Estos miembros de la simulación mock son extremadamente útiles en pruebas para identificar como es que estas funciones fueron ejecutadas o como se crearon sus instancias:</p>
<pre><code class="hljs css javascript"><span class="hljs-comment">// La función se ejecuto una sola vez</span>
expect(unaFuncionMock.mock.calls.length).toBe(<span class="hljs-number">1</span>);

<span class="hljs-comment">// El primer argumento de la primera llamada fue 'first arg'</span>
expect(unaFuncionMock.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-string">'first arg'</span>);

<span class="hljs-comment">// El segundo argumento de la primera llamada fue 'second arg'</span>
expect(unaFuncionMock.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]).toBe(<span class="hljs-string">'second arg'</span>);

<span class="hljs-comment">// Se crearon exactamente dos instancias de la función</span>
expect(unaFuncionMock.mock.instances.length).toBe(<span class="hljs-number">2</span>);

<span class="hljs-comment">// El primer objeto regresado de la primera instancia de esta función</span>
<span class="hljs-comment">// tenia una propiedad `name` con valor 'test'</span>
expect(unaFuncionMock.mock.instances[<span class="hljs-number">0</span>].name).toEqual(<span class="hljs-string">'test'</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="simular-valores-de-retorno"></a><a href="#simular-valores-de-retorno" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simular valores de retorno</h2>
<p>Las funciones simuladas mock pueden ser utilizadas para inyectar valores de prueba en el código de pruebas:</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myMock = jest.fn();
<span class="hljs-built_in">console</span>.log(myMock());
<span class="hljs-comment">// &gt; undefined</span>

myMock
  .mockReturnValueOnce(<span class="hljs-number">10</span>)
  .mockReturnValueOnce(<span class="hljs-string">'x'</span>)
  .mockReturnValue(<span class="hljs-literal">true</span>);

<span class="hljs-built_in">console</span>.log(myMock(), myMock(), myMock(), myMock());
<span class="hljs-comment">// &gt; 10, 'x', true, true</span>
</code></pre>
<p>Las funciones mock son también efectivas en código que ocupa un estilo funcional de llamadas continuas. Código escrito en este estilo evita la complejidad de crear módulos simulados que recreen la información del componente real que están sustituyendo, a favor de inyectar los valores en la prueba directamente donde van a ser utilizados.</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> filterTestFn = jest.fn();

<span class="hljs-comment">// Make the mock return `true` for the first call,</span>
<span class="hljs-comment">// and `false` for the second call</span>
filterTestFn.mockReturnValueOnce(<span class="hljs-literal">true</span>).mockReturnValueOnce(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">const</span> result = [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>].filter(filterTestFn);

<span class="hljs-built_in">console</span>.log(result);
<span class="hljs-comment">// &gt; [11]</span>
<span class="hljs-built_in">console</span>.log(filterTestFn.mock.calls);
<span class="hljs-comment">// &gt; [ [11], [12] ]</span>
</code></pre>
<p>La mayoría de ejemplos de código real involucran el conseguir una función mock de un componente dependencia y configurar ésta, pero la técnica aplicada es la misma. En esos casos, se debe evitar el implementar lógica dentro de cualquier función que no se este probando.</p>
<h2><a class="anchor" aria-hidden="true" name="implementaciones-de-simulaciones-mock"></a><a href="#implementaciones-de-simulaciones-mock" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementaciones de simulaciones mock</h2>
<p>Sin embargo, existen casos donde es útil no solo reemplazar los valores de retorno de una función, sino reemplazar la función por completo. Esto puede hacerse con <code>jest.fn</code> o el método <code>mockImplementationOnce</code> en funciones simuladas.</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myMockFn = jest.fn(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>));

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val));
<span class="hljs-comment">// &gt; true</span>

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val));
<span class="hljs-comment">// &gt; true</span>
</code></pre>
<p>El método <code>mockImplementation</code> es útil cuando se desea definir el comportamiento por defecto de una función mock que es creada en otro módulo:</p>
<pre><code class="hljs css js"><span class="hljs-comment">// foo.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// some implementation;</span>
};

<span class="hljs-comment">// test.js</span>
jest.mock(<span class="hljs-string">'../foo'</span>); <span class="hljs-comment">// this happens automatically with automocking</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../foo'</span>);

<span class="hljs-comment">// foo is a mock function</span>
foo.mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);
foo();
<span class="hljs-comment">// &gt; 42</span>
</code></pre>
<p>Cuando se requiere recrear comportamiento complejo de modo que diferentes llamadas una función simulada mock regresen diferentes resultados, se puede usar el método <code>mockImplementationOnce</code>:</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn()
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>));

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val));
<span class="hljs-comment">// &gt; true</span>

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val));
<span class="hljs-comment">// &gt; false</span>
</code></pre>
<p>Cuando se ejecuta la función escarnecida de implementaciones definidas con <code>mockImplementationOnce</code>, ejecutará la aplicación por defecto conjunto con <code>jest.fn</code> (si está definida):</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'default'</span>)
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'first call'</span>)
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'second call'</span>);

<span class="hljs-built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
<span class="hljs-comment">// &gt; 'first call', 'second call', 'default', 'default'</span>
</code></pre>
<p>Para casos donde haya métodos ejecutados en secuencia (y por lo tanto donde siempre se requiera regresar <code>this</code>), existe un API que simplifica de manera agradable esta situación, a través del método <code>.mockReturnThis()</code> que se encuentra en todos los mocks:</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myObj = {
  <span class="hljs-attr">myMethod</span>: jest.fn().mockReturnThis(),
};

<span class="hljs-comment">// is the same as</span>

<span class="hljs-keyword">const</span> otherObj = {
  <span class="hljs-attr">myMethod</span>: jest.fn(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }),
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="burlarse-de-los-nombres"></a><a href="#burlarse-de-los-nombres" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Burlarse de los nombres</h2>
<p>Opcionalmente puede proporcionar un nombre para sus funciones simuladas, que serán mostrado en lugar de &quot;jest.fn ()&quot; en la salida de error de prueba. Use esto si quiere poder identificar rápidamente la función simulada que informa un error en la salida de su prueba.</p>
<pre><code class="hljs css javascript"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn()
  .mockReturnValue(<span class="hljs-string">'default'</span>)
  .mockImplementation(<span class="hljs-function"><span class="hljs-params">scalar</span> =&gt;</span> <span class="hljs-number">42</span> + scalar)
  .mockName(<span class="hljs-string">'add42'</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="matchers-comunes"></a><a href="#matchers-comunes" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matchers comunes</h2>
<p>Finalmente, para simplificar el proceso de identificar como se llamaron las funciones simuladas mock, existen funciones de comparación personalizadas:</p>
<pre><code class="hljs css javascript"><span class="hljs-comment">// La función simulada fue llamada al menos una vez</span>
expect(mockFunc).toBeCalled();

<span class="hljs-comment">// La función simulada fue llamada al menos una vez con los argumentos especificados</span>
expect(mockFunc).toBeCalledWith(arg1, arg2);

<span class="hljs-comment">// La última llamada a la función simulada fue llamada con los argumentos especificados</span>
expect(mockFunc).lastCalledWith(arg1, arg2);

<span class="hljs-comment">// Todas las llamadas y el nombre del simulacro se escriben como una instantánea</span>
expect(mockFunc).toMatchSnapshot();
</code></pre>
<p>Estos métodos de comparacion, o matchers, son formas sencillas de inspeccionar la propiedad <code>.mock</code>. Siempre se pueden realizar las comparaciones manualmente si se desea hacer algo más especifico:</p>
<pre><code class="hljs css javascript"><span class="hljs-comment">// La función simulada fue llamada al menos una vez</span>
expect(mockFunc.mock.calls.length).toBeGreaterThan(<span class="hljs-number">0</span>);

<span class="hljs-comment">// La función simulada fue llamada al menos una vez con los argumentos especificados</span>
expect(mockFunc.mock.calls).toContain([arg1, arg2]);

<span class="hljs-comment">// La última llamada a la función simulada fue llamada con los argumentos especificados</span>
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>]).toEqual([
  arg1,
  arg2,
]);

<span class="hljs-comment">// El primer argumento de la última llamada a la función simulada fue `42`</span>
<span class="hljs-comment">// (tenga en cuenta que no hay azúcar auxiliar para este específico de una afirmación)</span>
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">42</span>);
<span class="hljs-comment">// Una instantánea comprobará que se invocó un simulacro la misma cantidad de veces,</span>
<span class="hljs-comment">// en el mismo orden, con los mismos argumentos. También afirmará en el nombre.</span>
expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);
expect(mockFunc.mock.getMockName()).toBe(<span class="hljs-string">'a mock name'</span>);
</code></pre>
<p>Para una lista completa de matchers, véase los documentos de referencia <a href="/jest/docs/es-ES/22.3/expect.html">reference docs</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="setup-teardown.html">← Setup and Teardown</a><a class="docs-next button" href="jest-platform.html">Jest Platform →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/es-ES/getting-started.html">Getting Started</a><a href="/jest/docs/es-ES/snapshot-testing.html">Guides</a><a href="/jest/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/es-ES/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discord.gg/MWRhKCj">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script></body></html>