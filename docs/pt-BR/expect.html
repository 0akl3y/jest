<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Quando você está escrevendo testes, muitas das vezes você precisa checar se os valores satisfazem certas condições. `expect` lhe dá acesso a inúmeros &quot;matchers&quot; que permitem validar diferentes coisas."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/pt-BR/getting-started.html" target="_self">Documentação</a></li><li><a href="/jest/docs/pt-BR/api.html" target="_self">API</a></li><li><a href="/jest/pt-BR/help.html" target="_self">Ajuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/pt-BR/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/snapshot-testing.html">Teste de Snapshot</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>Quando você está escrevendo testes, muitas das vezes você precisa checar se os valores satisfazem certas condições. <code>expect</code> lhe dá acesso a inúmeros &quot;matchers&quot; que permitem validar diferentes coisas.</p>
<h2><a class="anchor" name="metodos"></a>Métodos <a class="hash-link" href="#metodos">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referencia"></a>Referência <a class="hash-link" href="#referencia">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p>A função <code>expect</code> é usada toda vez que você quer testar um valor. Você raramente irá usar o <code>expect</code> sozinho. Em vez disso, você irá usar <code>expect</code> junto com uma função &quot;matcher&quot; para verificar algo sobre um valor.</p>
<p>É mais fácil de entender isto com um exemplo. Digamos que você tenha um método <code>bestLaCroixFlavor()</code> que se espera retornar a string <code>'grapefruit'</code>. Veja como você testaria isso:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>Neste caso, <code>toBe</code> é a função &quot;matcher&quot;. Existem muitas funções &quot;matcher&quot; diferentes, documentadas abaixo, para ajuda-lo a testar coisas diferentes.</p>
<p>O argumento para <code>expect</code> deve ser o valor que o seu código produz, e qualquer argumento para o matcher deve ser o valor correto esperado. Se você misturá-los, os testes ainda irão funcionar, mas as mensagens de erro em testes que falharem vão parecer estranhas.</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p>Você pode usar <code>expect.extend</code> para adicionar seus próprios &quot;matchers&quot; em Jest. Por exemplo, digamos que você está testando uma biblioteca de teoria de números e que frequentemente está verificando que os números são divisíveis por outros números. Você poderia abstrair isso em um &quot;matcher&quot; <code>toBeDivisibleBy</code>:</p>
<pre><code class="language-js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = (received % argument == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Matchers devem retornar um objeto com duas chaves. <code>pass</code> indica se houve ou não uma correspondência, e <code>message</code> fornece uma função sem argumentos que retorna uma mensagem de erro em caso de falha. Assim, quando <code>pass</code> é falso, <code>message</code> deve retornar a mensagem de erro quando <code>expect(x).yourMatcher()</code> falha. E quando <code>pass</code> é verdadeiro, a <code>mensagem</code> deve retornar a mensagem de erro quando <code>expect(x).not.yourMatcher()</code> falha.</p>
<p>Essas funções auxiliares podem ser encontradas em <code>this</code> dentro de um &quot;matcher&quot; personalizado:</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>Um valor booleano para que você saiba que este &quot;matcher&quot; foi chamado com o modificador negado <code>.not</code> permitindo você inverter sua verificação.</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>Esta é uma função de igualdade profunda que retornará <code>true</code> se dois objetos têm os mesmos valores (recursivamente).</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p>Há uma série de ferramentas úteis expostas em <code>this.utils</code> consistindo principalmente das exportações de <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Os mais úteis são <code>matcherHint</code>, <code>printExpected</code> e <code>printReceived</code> para formatar bem as mensagens de erro. Por exemplo, dê uma olhada na implementação para o &quot;matcher&quot; <code>toBe</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Isto imprimirá algo como isto:</p>
<pre><code>  expect(received).toBe(expected)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>Quando uma verificação falha, a mensagem de erro deve dar o máximo de informação necessária para o usuário, para que eles possam resolver seu problema rapidamente. Você deve criar uma mensagem de falha precisa para certificar-se de que os usuários de suas verificações personalizados tenham uma boa experiência de desenvolvimento.</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> corresponde a qualquer coisa menos <code>null</code> ou <code>undefined</code>. Você pode usá-lo dentro de <code>toEqual</code> ou <code>toBeCalledWith</code> em vez de um valor literal. Por exemplo, se você quiser verificar que uma função de simulação (mock, em inglês) é chamada com um argumento não nulo:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> corresponde a qualquer coisa que foi criada com o construtor fornecido. Você pode usá-lo dentro de <code>toEqual</code> ou <code>toBeCalledWith</code> em vez de um valor literal. Por exemplo, se você quiser verificar que uma função de simulação (mock, em inglês) é chamada com um número:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> corresponde a um array recebido que contém todos os elementos no array esperado. Ou seja, o array esperado é um <strong>subconjunto</strong> do array recebido. Portanto, combina com um array recebido que contém elementos que <strong>não</strong> estão no array esperado.</p>
<p>Você pode usá-lo em vez de um valor literal:</p>
<ul>
<li>em <code>toEqual</code> ou <code>toBeCalledWith</code></li>
<li>para corresponder a uma propriedade em <code>objectContaining</code> ou <code>toMatchObject</code></li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> verifica que um certo número de verificações são chamadas durante um teste. Isto é frequentemente útil ao testar código assíncrono, a fim de certificar-se que as verificações de um &quot;callback&quot; realmente tenham sido chamadas.</p>
<p>Por exemplo, digamos que temos uma função <code>doAsync</code> que recebe duas &quot;callbacks&quot; <code>callback1</code> e <code>callback2</code>, de forma assíncrona chamará as duas numa ordem desconhecida. Podemos testar isso com:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>A chamada <code>expect.assertions(2)</code> garante que as duas &quot;callbacks&quot; sejam realmente chamadas.</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code> verifica que pelo menos uma verificação é chamada durante um teste. Isto é frequentemente útil ao testar código assíncrono, a fim de certificar-se que as verificações de um &quot;callback&quot; realmente tenham sido chamadas.</p>
<p>Por exemplo, digamos que nós temos algumas funções onde todas lidam com estado. <code>prepareState</code> chama um &quot;callback&quot; com um objeto de estado, <code>validateState</code> é executado nesse objeto de estado, e <code>waitOnState</code> retorna uma promessa que aguarda até que todas as &quot;callbacks&quot; <code>prepareState</code> completem. Podemos testar isso com:</p>
<pre><code class="language-js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>A chamada <code>expect.hasAssertions()</code> garante que a &quot;callback&quot; <code>prepareState</code> é realmente chamada.</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> corresponde a qualquer objeto recebido que recursivamente coincide com as propriedades esperadas. Ou seja, o objeto esperado é um <strong>subconjunto</strong> do objeto recebido. Portanto, combina com um objeto recebido que contém propriedades que <strong>não</strong> estão no objeto esperado.</p>
<p>Em vez de valores literais de propriedade no objeto esperado, você pode usar &quot;matchers&quot;, <code>expect.anything()</code>, e assim por diante.</p>
<p>Por exemplo, digamos que esperamos uma função <code>onPress</code> ser chamada com um objeto <code>Event</code>, e tudo que precisamos verificar é que o evento tem propriedades <code>event.x</code> e <code>event.y</code>. Podemos fazer isso com:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="disponivel-no-jest-1900"></a>disponível no Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponivel-no-jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code> corresponde a qualquer string recebida que contém a exata string esperada.</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(regexp)</code> corresponde a qualquer string recebida que coincide com o regexp esperado.</p>
<p>Você pode usá-lo em vez de um valor literal:</p>
<ul>
<li>em <code>toEqual</code> ou <code>toBeCalledWith</code></li>
<li>para corresponder a um elemento em <code>arrayContaining</code></li>
<li>para corresponder a uma propriedade em <code>objectContaining</code> ou <code>toMatchObject</code></li>
</ul>
<p>Este exemplo também mostra como você pode aninhar vários &quot;matchers&quot; assimétricos, com <code>expect.stringMatching</code> dentro de <code>expect.arrayContaining</code>.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p>Você pode chamar <code>expect.addSnapshotSerializer</code> para adicionar um módulo que formata estruturas de dados específicas da aplicação.</p>
<p>Para um arquivo de teste individual, um módulo adicionado precede quaisquer módulos da configuração <code>snapshotSerializers</code>, que precedem os serializadores de snapshot padrão para tipos internos de JavaScript e para elementos React. O último módulo adicionado é o primeiro módulo testado.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// affects expect(value).toMatchSnapshot() assertions in the test file</span>
</code></pre>
<p>Se você adicionar um serializador de snapshot em arquivos de teste individual em vez de adicioná-lo à configuração <code>snapshotSerializers</code>:</p>
<ul>
<li>Você torna a dependência explícita em vez de implícita.</li>
<li>Você evita limites à configuração que podem fazer com que você tenha que ejetar <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/pt-BR/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>Se você sabe como testar algo, <code>.not</code> permite que você teste seu oposto. Por exemplo, este código testa que o melhor sabor da La Croix não é &quot;coconut&quot;:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="disponivel-no-jest-2000"></a>disponível no Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponivel-no-jest-2000">#</a></h5>
<p>Use <code>resolves</code> para decodificar o valor de uma promessa cumprida, para que qualquer outro matcher possa então ser encadeado. Se a promessa for rejeitada a verificação falhará.</p>
<p>Por exemplo, este código de testes que a promessa resolve e que o valor resultante é <code>'lemon'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Como alternativa, você pode usar <code>async/await</code> em combinação com <code>.resolves</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="disponivel-no-jest-2000"></a>disponível no Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponivel-no-jest-2000">#</a></h5>
<p>Use <code>.rejects</code> para decodificar o motivo de uma promessa rejeitada, para que qualquer outro matcher possa ser encadeado. Se a promessa é cumprida a verificação falhará.</p>
<p>Por exemplo, este código testa que a promessa rejeite com um motivo:</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBeDefined();
});
</code></pre>
<p>Como alternativa, você pode usar <code>async/await</code> em combinação com <code>.rejects</code>. Além disso, esse código testa que o motivo retornado inclui 'octopus':</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> drinkOctopus = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  });

  <span class="hljs-keyword">await</span> expect(drinkOctopus).rejects.toMatch(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> só verifica que um valor é o que você espera. Ele usa <code>===</code> para verificar igualdade estrita.</p>
<p>Por exemplo, este código irá validar algumas propriedades do objeto <code>can</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Não use <code>toBe</code> com números de ponto flutuante. Por exemplo, devido a arredondamentos, em JavaScript <code>0.2 + 0.1</code> não é estritamente igual a <code>0.3</code>. Se você tem números de ponto flutuante, tente usar de preferência <code>.toBeCloseTo</code>.</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>Também sob o pseudônimo: <code>.toBeCalled()</code></p>
<p>Use <code>.toHaveBeenCalled</code> para garantir que uma função de simulação (mock, em inglês) foi chamada.</p>
<p>Por exemplo, vamos dizer você tem uma função <code>drinkAll(drink, flavor)</code> que usa uma função <code>drink</code> e aplica a todas as bebidas disponíveis. Você pode querer verificar que <code>drink</code> é chamada por <code>'lemon'</code>, mas não para <code>'octopus'</code>, porque o sabor <code>'octopus'</code> é realmente estranho e por que alguma coisa teria sabor de 'octopus' (polvo)? Você pode fazer isso com este conjunto de testes:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>Use <code>.toHaveBeenCalledTimes</code> para garantir que uma função de simulação (mock, em inglês) foi chamada um número exato de vezes.</p>
<p>Por exemplo, vamos dizer você tem uma função <code>drinkEach(drink, Array&lt;flavor&gt;)</code> que usa uma função <code>drink</code> e aplica ela ao array das bebidas passadas. Você pode querer verificar que a função &quot;drink&quot; foi chamada um número exato de vezes. Você pode fazer isso com este conjunto de testes:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>Também sob o pseudônimo: <code>.toBeCalledWith()</code></p>
<p>Use <code>.toHaveBeenCalledWith</code> para garantir que uma função de simulação (mock, em inglês) foi chamada com argumentos específicos.</p>
<p>Por exemplo, digamos que você pode registrar uma bebida com uma função <code>register</code>, e <code>applyToAll(f)</code> deve aplicar a função <code>f</code> para todas as bebidas registradas. Para garantir que isso funciona, você poderia escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>Também sob o pseudônimo: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Se você tiver uma função de simulação (mock, em inglês), você pode usar <code>.toHaveBeenLastCalledWith</code> para testar com quais argumentos foi chamada na última vez. Por exemplo, digamos que você tem uma função <code>applyToAllFlavors(f)</code> que aplica <code>f</code> para um monte de sabores, e você deseja garantir que quando você chamá-la, o último sabor em que ela opera é <code>'mango'</code>. Você pode escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumber-numdigits"></a><code>.toBeCloseTo(number, numDigits)</code> <a class="hash-link" href="#tobeclosetonumber-numdigits">#</a></h3>
<p>Usando a igualdade exata com números de ponto flutuante é uma má ideia. Arredondamento significa que coisas intuitivas falharão. Por exemplo, este teste vai falhar:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>Ele falha porque em JavaScript, <code>0.2 + 0.1</code> na verdade é <code>0.30000000000000004</code>. Me desculpe.</p>
<p>Em vez disso, use <code>.toBeCloseTo</code>. Use <code>numDigits</code> para controlar quantos dígitos verificar após o ponto decimal. Por exemplo, se você quer ter certeza que <code>0.2 + 0.1</code> é igual a <code>0.3</code>, com uma precisão de 5 casas decimais, você pode usar este teste:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>O valor padrão para <code>numDigits</code> é 2, que provou ser um bom padrão na maioria dos casos.</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>Use <code>.toBeDefined</code> para verificar que uma variável não &quot;undefined&quot;. Por exemplo, se você quiser verificar que uma função <code>fetchNewFlavorIdea()</code> retorna <em>alguma cpisa</em>, você pode escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>Você poderia escrever <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, mas é uma melhor prática evitar referência a <code>undefined</code> diretamente em seu código.</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>Usar <code>.toBeFalsy</code> quando você não se importa qual valor é, você só quer garantir que um valor é &quot;false&quot; em um contexto booleano. Por exemplo, digamos que você tem algum código de aplicativo que se parece com:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Você pode não se importar com o que <code>getErrors</code> retorna, especificamente - ele pode retornar <code>false</code>, <code>null</code> ou ``, e seu código ainda funcionaria. Então se você quiser testar que não existem erros depois de beber algumas La Croix, você poderia escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>Em JavaScript, existem seis valores &quot;falsy&quot; (que se traduzem em falso quando avaliados em um contexto booleano): <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> e <code>NaN</code>. Todo o resto é &quot;truthy&quot; (se traduzem em verdadeiro quando avaliados em um contexto booleano).</p>
<h3><a class="anchor" name="tobegreaterthannumber"></a><code>.toBeGreaterThan(number)</code> <a class="hash-link" href="#tobegreaterthannumber">#</a></h3>
<p>Para comparar números com ponto flutuante, você pode usar <code>toBeGreaterThan</code>. Por exemplo, se você quiser testar que <code>ouncesPerCan()</code> retorna um valor maior que 10 onças, escreva:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumber"></a><code>.toBeGreaterThanOrEqual(number)</code> <a class="hash-link" href="#tobegreaterthanorequalnumber">#</a></h3>
<p>Para comparar números com ponto flutuante, você pode usar <code>toBeGreaterThanOrEqual</code>. Por exemplo, se você quiser testar que <code>ouncesPerCan()</code> retorna um valor de pelo menos 12 onças, escreva:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumber"></a><code>.toBeLessThan(number)</code> <a class="hash-link" href="#tobelessthannumber">#</a></h3>
<p>Para comparar números com ponto flutuante, você pode usar <code>toBeLessThan</code>. Por exemplo, se você quiser testar que <code>ouncesPerCan()</code> retorna um valor menor que 20 onças, escreva:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumber"></a><code>.toBeLessThanOrEqual(number)</code> <a class="hash-link" href="#tobelessthanorequalnumber">#</a></h3>
<p>Para comparar números com ponto flutuante, você pode usar <code>toBeLessThanOrEqual</code>. Por exemplo, se você quiser testar que <code>ouncesPerCan()</code> retorna um valor de no máximo 12 onças, escreva:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>Use <code>.toBeInstanceOf(Class)</code> para verificar que um objeto é uma instância de uma classe. Este &quot;matcher&quot; usa <code>instanceof</code> por debaixo.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> é o mesmo que <code>.toBe(null)</code>, mas as mensagens de erro são um pouco mais agradáveis. Então use <code>.toBeNull()</code> quando você deseja verificar que algo é nulo.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>Usar <code>.toBeTruthy</code> quando você não se importa qual valor é, você só quer garantir que um valor é verdadeiro em um contexto booleano. Por exemplo, digamos que você tem algum código de aplicativo que se parece com:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Você pode não se importar o que <code>thirstInfo</code> retorna, especificamente - ele pode retornar <code>true</code> ou um objeto complexo, e seu código ainda funcionaria. Então se você quiser apenas testar que <code>thirstInfo</code> será &quot;truthy&quot; depois de beber algumas La Croix, você poderia escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>Em JavaScript, existem seis valores &quot;falsy&quot; (que se traduzem em falso quando avaliados em um contexto booleano): <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> e <code>NaN</code>. Todo o resto é &quot;truthy&quot; (se traduzem em verdadeiro quando avaliados em um contexto booleano).</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>Use <code>.toBeUndefined</code> para verificar se uma variável é &quot;undefined&quot;. Por exemplo, se você quiser verificar que uma função <code>bestDrinkForFlavor(flavor)</code> retornará <code>undefined</code> para o sabor <code>'octopus'</code>, porque não há nenhuma boa bebida com sabor &quot;octopus&quot;, ou polvo:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>Você poderia escrever <code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>, mas é uma melhor prática evitar se referir a <code>undefined</code> diretamente em seu código.</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>Use <code>.toContain</code> quando você deseja verificar se um item está em um array. Para testar os itens no array, este usa <code>===</code>, uma verificação de igualdade estrita. <code>.toContain</code> também pode verificar se uma string é uma substring de outra string.</p>
<p>Por exemplo, se <code>getAllFlavors()</code> retorna um array de sabores e você quer ter certeza que <code>lime</code> está lá, você pode escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>Use <code>.toContainEqual</code> quando você deseja verificar que um item com uma estrutura específica e valores está contido em um array. Para testar os itens no array, este &quot;matcher&quot; recursivamente verifica a igualdade de todos os campos, em vez de verificar a identidade do objeto.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>Use <code>.toEqual</code> quando você deseja verificar se dois objetos têm o mesmo valor. Este &quot;matcher&quot; recursivamente verifica a igualdade de todos os campos, em vez de verificar a identidade do objeto — isso é também conhecido como &quot;igualdade profunda&quot;. Por exemplo, <code>toEqual</code> e <code>toBe</code> se comportam diferentemente neste conjunto de testes, para que todos os testes passem:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Nota: <code>.toEqual</code> não irá executar uma verificação de <em>igualdade profunda</em> para dois erros. Apenas a propriedade <code>message</code> de um Error é considerada pela igualdade. É recomendável usar o &quot;matcher&quot; <code>.toThrow</code> para testes contra erros.</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>Use <code>.toHaveLength</code> para verificar que um objeto tem uma propriedade <code>.length</code> e está definida para um determinado valor numérico.</p>
<p>Isto é especialmente útil para verificar arrays ou tamanho de strings.</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>Use <code>.toMatch</code> para verificar se uma string corresponde a uma expressão regular.</p>
<p>Por exemplo, você talvez não saiba o que exatamente <code>essayOnTheBestFlavor()</code> retorna, mas você sabe que é uma string muito longa, e a substring <code>grapefruit</code> deve estar em algum lugar. Você pode testar isso com:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>Este &quot;matcher&quot; também aceita uma string, a qual tentará corresponder:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>Use <code>.toMatchObject</code> para verificar se um objeto JavaScript corresponde a um subconjunto das propriedades de um objeto. Combinará objetos recebidos com propriedades que <strong>não</strong> estão no objeto esperado.</p>
<p>Você também pode passar uma array de objetos, neste caso o método retornará verdadeiro somente se cada objeto na matriz recebida corresponder (no sentido <code>toMatchObject</code> descrito acima) o objeto correspondente no array esperado. Isso é útil se você deseja verificar que dois arrays correspondem em seu número de elementos, em oposição a <code>arrayContaining</code>, que permite elementos extras no array recebido.</p>
<p>Você pode corresponder propriedades contra valores ou &quot;matchers&quot;.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertykeypath-value"></a><code>.toHaveProperty(keyPath, value)</code> <a class="hash-link" href="#tohavepropertykeypath-value">#</a></h3>
<p>Use <code>.toHaveProperty</code> para verificar se a propriedade fornecida na referência <code>keyPath</code> existe para um objeto. Para verificação de propriedades aninhadas profundamente em um objeto use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> para referências profundas.</p>
<p>Opcionalmente, você pode fornecer um <code>value</code> para verificar se é igual ao valor presente no <code>keyPath</code> no objeto de destino. Este &quot;matcher&quot; usa 'igualdade profunda' (como <code>toEqual()</code>) e recursivamente verifica a igualdade de todos os campos.</p>
<p>O exemplo a seguir contém um objeto <code>houseForSale</code> com propriedades aninhadas. Estamos usando <code>toHaveProperty</code> para verificar a existência e valores de várias propriedades no objeto.</p>
<pre><code class="language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/pt-BR/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>Você também pode especificar um nome opcional de snapshot. Caso contrário, o nome é inferido a partir do teste.</p>
<p><em>Nota: Embora teste de snapshot é mais comumente usado com componentes React, qualquer valor serializado pode ser usado como um snapshot.</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>Também sob o pseudônimo: <code>.toThrowError(error)</code></p>
<p>Use <code>.toThrow</code> para testar que uma função é capaz de lançar erros quando é chamada. Por exemplo, se queremos testar que <code>drinkFlavor('octopus')</code> lança um erro, porque o sabor &quot;octopus&quot;, ou polvo, é muito nojento para beber, podemos escrever:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>Se você deseja testar que um erro específico é lançado, você pode fornecer um argumento para <code>toThrow</code>. O argumento pode ser uma string para a mensagem de erro, uma classe para o erro, ou uma regex que deve coincidir com o erro. Por exemplo, digamos que <code>drinkFlavor</code> é codificado como segue:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>Podemos fazer um teste se esse erro é lançado de diversas maneiras:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>Use <code>.toThrowErrorMatchingSnapshot</code> para testar que uma função lança um erro que corresponde ao snapshot mais recente quando é chamada. Por exemplo, digamos que você tem uma função <code>drinkFlavor</code> que lança um erro sempre que o sabor é <code>'octopus'</code>, e é codificada como segue:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>O teste para esta função ficará assim:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>E irá gerar o seguinte snapshot:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>Confira <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a> para obter mais informações sobre testes de snapshot.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/pt-BR/getting-started.html">Getting Started</a><a href="/jest/docs/pt-BR/snapshot-testing.html">Guides</a><a href="/jest/docs/pt-BR/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/pt-BR/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>